(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) :
  typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VueGL = {}, global.THREE));
}(this, (function (exports, three) { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var add = 'add';
  var remove = 'remove';
  var change = 'change';
  var inst = 'inst';
  var name = 'name';
  var image = 'image';
  var fog = 'fog';
  var overrideMaterial = 'overrideMaterial';
  var environment = 'environment';
  var background = 'background';
  var mapping = 'mapping';
  var wrapS = 'wrapS';
  var wrapT = 'wrapT';
  var magFilter = 'magFilter';
  var minFilter = 'minFilter';
  var anisotropy = 'anisotropy';
  var format = 'format';
  var type = 'type';
  var offsetU = 'offsetU';
  var offsetV = 'offsetV';
  var repeatU = 'repeatU';
  var repeatV = 'repeatV';
  var rotation = 'rotation';
  var centerU = 'centerU';
  var centerV = 'centerV';
  var premultiplyAlpha = 'premultiplyAlpha';
  var unpackAlignment = 'unpackAlignment';
  var encoding = 'encoding';
  var noFlipY = 'noFlipY';
  var color = 'color';
  var near = 'near';
  var far = 'far';
  var alpha = 'alpha';
  var noPremultipliedAlpha = 'noPremultipliedAlpha';
  var antialias = 'antialias';
  var noStencil = 'noStencil';
  var preserveDrawingBuffer = 'preserveDrawingBuffer';
  var noDepth = 'noDepth';
  var logarithmicDepthBuffer = 'logarithmicDepthBuffer';
  var shadowMapEnabled = 'shadowMapEnabled';
  var precision = 'precision';
  var powerPreference = 'powerPreference';
  var camera = 'camera';
  var scene = 'scene';
  var material = 'material';
  var geometry = 'geometry';
  var map = 'map';
  var alphaMap = 'alphaMap';
  var fragmentShader = 'fragmentShader';
  var uniforms = 'uniforms';
  var vertexShader = 'vertexShader';
  var wireframe = 'wireframe';
  var size = 'size';
  var noSizeAttenuation = 'noSizeAttenuation';
  var clearcoat = 'clearcoat';
  var clearcoatRoughness = 'clearcoatRoughness';
  var reflectivity = 'reflectivity';
  var specular = 'specular';
  var shininess = 'shininess';
  var side = 'side';
  var vertexColors = 'vertexColors';
  var defines = 'defines';
  var linewidth = 'linewidth';
  var dashSize = 'dashSize';
  var gapSize = 'gapSize';
  var linecap = 'linecap';
  var linejoin = 'linejoin';
  var distance = 'distance';
  var decay = 'decay';
  var angle = 'angle';
  var penumbra = 'penumbra';
  var target = 'target';
  var width = 'width';
  var height = 'height';
  var intensity = 'intensity';
  var groundColor = 'groundColor';
  var light = 'light';
  var radius = 'radius';
  var radials = 'radials';
  var circles = 'circles';
  var divisions = 'divisions';
  var color1 = 'color1';
  var color2 = 'color2';
  var colorCenterLine = 'colorCenterLine';
  var colorGrid = 'colorGrid';
  var object = 'object';
  var directionX = 'directionX';
  var directionY = 'directionY';
  var directionZ = 'directionZ';
  var length = 'length';
  var headLength = 'headLength';
  var headWidth = 'headWidth';
  var tube = 'tube';
  var radialSegments = 'radialSegments';
  var tubularSegments = 'tubularSegments';
  var p = 'p';
  var q = 'q';
  var arc = 'arc';
  var text = 'text';
  var depth = 'depth';
  var curveSegments = 'curveSegments';
  var steps = 'steps';
  var bevelEnabled = 'bevelEnabled';
  var bevelThickness = 'bevelThickness';
  var bevelSize = 'bevelSize';
  var bevelOffset = 'bevelOffset';
  var bevelSegments = 'bevelSegments';
  var extrudePath = 'extrudePath';
  var uvGenerator = 'uvGenerator';
  var font = 'font';
  var detail = 'detail';
  var widthSegments = 'widthSegments';
  var heightSegments = 'heightSegments';
  var phiStart = 'phiStart';
  var phiLength = 'phiLength';
  var thetaStart = 'thetaStart';
  var thetaLength = 'thetaLength';
  var shapes = 'shapes';
  var phiSegments = 'phiSegments';
  var thetaSegments = 'thetaSegments';
  var outerRadius = 'outerRadius';
  var innerRadius = 'innerRadius';
  var vertices = 'vertices';
  var indices = 'indices';
  var points = 'points';
  var segments = 'segments';
  var radiusTop = 'radiusTop';
  var radiusBottom = 'radiusBottom';
  var openEnded = 'openEnded';
  var depthSegments = 'depthSegments';
  var holes = 'holes';
  var d = 'd';
  var src = 'src';
  var data = 'data';
  var autoClose = 'autoClose';
  var position = 'position';
  var positionX = 'positionX';
  var positionY = 'positionY';
  var positionZ = 'positionZ';
  var positionRadius = 'positionRadius';
  var positionPhi = 'positionPhi';
  var positionTheta = 'positionTheta';
  var rotationX = 'rotationX';
  var rotationY = 'rotationY';
  var rotationZ = 'rotationZ';
  var rotationW = 'rotationW';
  var rotationOrder = 'rotationOrder';
  var lookAtX = 'lookAtX';
  var lookAtY = 'lookAtY';
  var lookAtZ = 'lookAtZ';
  var scaleX = 'scaleX';
  var scaleY = 'scaleY';
  var scaleZ = 'scaleZ';
  var castShadow = 'castShadow';
  var receiveShadow = 'receiveShadow';
  var hidden = 'hidden';
  var drawRangeStart = 'drawRangeStart';
  var drawRangeCount = 'drawRangeCount';
  var groups = 'groups';
  var normalized = 'normalized';
  var itemSize = 'itemSize';
  var usage = 'usage';
  var array = 'array';
  var zoom = 'zoom';
  var fov = 'fov';
  var aspect = 'aspect';
  var left = 'left';
  var right = 'right';
  var top = 'top';
  var bottom = 'bottom';
  var euler = 'euler';
  var quaternion = 'quaternion';
  var lookAt = 'lookAt';
  var rectangular = 'rectangular';
  var spherical = 'spherical';
  var xAxisColor = 'xAxisColor';
  var yAxisColor = 'yAxisColor';
  var zAxisColor = 'zAxisColor';

  var VglSlotable = {
    inject: {
      $_vglSlot: {
        default: {
          $emit: function $emit() {}
        }
      }
    },
    created: function created() {
      this.$_vglSlot.$emit(add, this[inst]);
    },
    beforeDestroy: function beforeDestroy() {
      this.$_vglSlot.$emit(remove, this[inst]);
    },
    beforeUpdate: function beforeUpdate() {
      this.$_vglSlot.$emit(change);
    },
    watch: _defineProperty({}, inst, function (newInst, oldInst) {
      this.$_vglSlot.$emit(remove, oldInst);
      this.$_vglSlot.$emit(add, newInst);
    }),
    methods: _defineProperty({}, change, function () {
      this.$_vglSlot.$emit(change);
    })
  };

  var VglSlot = {
    emits: [add, remove, change],
    provide: function provide() {
      return {
        $_vglSlot: this
      };
    },
    render: function render(h) {
      return h('template', this.$slots.default);
    }
  };

  var VglSlotHolder = {
    render: function render(h) {
      var _this = this;

      return h('template', Object.entries(this.$slots).map(function (_ref) {
        var _on;

        var _ref2 = _slicedToArray(_ref, 2),
            name = _ref2[0],
            slot = _ref2[1];

        return h(VglSlot, {
          key: name,
          on: (_on = {}, _defineProperty(_on, add, function (obj) {
            return _this[add](name, obj);
          }), _defineProperty(_on, remove, function (obj) {
            return _this[remove](name, obj);
          }), _defineProperty(_on, change, function () {
            return _this[change](name);
          }), _on)
        }, slot);
      }));
    }
  };

  var _props$A, _watch$n, _methods$o;

  function chars(order) {
    return order.trim().toUpperCase().split(/\s*/);
  }
  /** A basic object representation. */


  var VglObject3d = {
    mixins: [VglSlotable, VglSlotHolder],
    props: (_props$A = {}, _defineProperty(_props$A, position, {
      type: String,
      default: rectangular,
      validator: function validator(p) {
        return [rectangular, spherical].includes(p);
      }
    }), _defineProperty(_props$A, positionX, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, positionY, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, positionZ, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, positionRadius, {
      type: Number,
      default: 1
    }), _defineProperty(_props$A, positionPhi, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, positionTheta, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, rotation, {
      type: String,
      default: euler,
      validator: function validator(r) {
        return [euler, quaternion, lookAt].includes(r);
      }
    }), _defineProperty(_props$A, rotationX, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, rotationY, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, rotationZ, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, rotationW, {
      type: Number,
      default: 1
    }), _defineProperty(_props$A, rotationOrder, {
      type: String,
      default: 'XYZ',
      validator: function validator(order) {
        return chars(order).sort().join('') === 'XYZ';
      }
    }), _defineProperty(_props$A, lookAtX, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, lookAtY, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, lookAtZ, {
      type: Number,
      default: 0
    }), _defineProperty(_props$A, scaleX, {
      type: Number,
      default: 1
    }), _defineProperty(_props$A, scaleY, {
      type: Number,
      default: 1
    }), _defineProperty(_props$A, scaleZ, {
      type: Number,
      default: 1
    }), _defineProperty(_props$A, castShadow, Boolean), _defineProperty(_props$A, receiveShadow, Boolean), _defineProperty(_props$A, name, {
      type: String,
      default: ''
    }), _defineProperty(_props$A, hidden, Boolean), _props$A),
    computed: _defineProperty({}, inst, function () {
      return new three.Object3D();
    }),
    watch: (_watch$n = {}, _defineProperty(_watch$n, inst, function (obj, _ref) {
      var p = _ref.position,
          r = _ref.rotation,
          scale = _ref.scale,
          cs = _ref.castShadow,
          rs = _ref.receiveShadow,
          visible = _ref.visible,
          n = _ref.name;
      obj.position.copy(p);
      obj.rotation.copy(r);
      obj.scale.copy(scale);
      Object.assign(obj, {
        castShadow: cs,
        receiveShadow: rs,
        visible: visible,
        name: n
      });
    }), _defineProperty(_watch$n, name, {
      handler: function handler(n) {
        this[inst].name = n;
      },
      immediate: true
    }), _defineProperty(_watch$n, positionX, function (x) {
      if (this[position] === rectangular) {
        this[inst].position.x = x;

        if (this[rotation] === lookAt) {
          this[inst].lookAt(this[lookAtX], this[lookAtY], this[lookAtZ]);
        }
      }
    }), _defineProperty(_watch$n, positionY, function (y) {
      if (this[position] === rectangular) {
        this[inst].position.y = y;

        if (this[rotation] === lookAt) {
          this[inst].lookAt(this[lookAtX], this[lookAtY], this[lookAtZ]);
        }
      }
    }), _defineProperty(_watch$n, positionZ, function (z) {
      if (this[position] === rectangular) {
        this[inst].position.z = z;

        if (this[rotation] === lookAt) {
          this[inst].lookAt(this[lookAtX], this[lookAtY], this[lookAtZ]);
        }
      }
    }), _defineProperty(_watch$n, positionRadius, function (r) {
      if (this[position] === spherical) {
        this[inst].position.setFromSphericalCoords(r, this[positionPhi], this[positionTheta]);

        if (this[rotation] === lookAt) {
          this[inst].lookAt(this[lookAtX], this[lookAtY], this[lookAtZ]);
        }
      }
    }), _defineProperty(_watch$n, positionPhi, function (p) {
      if (this[position] === spherical) {
        this[inst].position.setFromSphericalCoords(this[positionRadius], p, this[positionTheta]);

        if (this[rotation] === lookAt) {
          this[inst].lookAt(this[lookAtX], this[lookAtY], this[lookAtZ]);
        }
      }
    }), _defineProperty(_watch$n, positionTheta, function (t) {
      if (this[position] === spherical) {
        this[inst].position.setFromSphericalCoords(this[positionRadius], this[positionPhi], t);

        if (this[rotation] === lookAt) {
          this[inst].lookAt(this[lookAtX], this[lookAtY], this[lookAtZ]);
        }
      }
    }), _defineProperty(_watch$n, position, {
      handler: function handler(p) {
        if (p === rectangular) {
          this[inst].position.set(this[positionX], this[positionY], this[positionZ]);
        } else {
          this[inst].position.setFromSphericalCoords(this[positionRadius], this[positionPhi], this[positionTheta]);
        }

        if (this[rotation] === lookAt) {
          this[inst].lookAt(this[lookAtX], this[lookAtY], this[lookAtZ]);
        }
      },
      immediate: true
    }), _defineProperty(_watch$n, rotation, {
      handler: function handler(r) {
        if (r === euler) {
          this[inst].rotation.set(this[rotationX], this[rotationY], this[rotationZ], chars(this[rotationOrder]).join(''));
        } else if (r === quaternion) {
          this[inst].quaternion.set(this[rotationX], this[rotationY], this[rotationZ], this[rotationW]);
        } else {
          this[inst].lookAt(this[lookAtX], this[lookAtY], this[lookAtZ]);
        }
      },
      immediate: true
    }), _defineProperty(_watch$n, rotationX, function (x) {
      if (this[rotation] === euler) this[inst].rotation.x = x;else if (this[rotation] === quaternion) this[inst].quaternion.x = x;
    }), _defineProperty(_watch$n, rotationY, function (y) {
      if (this[rotation] === euler) this[inst].rotation.y = y;else if (this[rotation] === quaternion) this[inst].quaternion.y = y;
    }), _defineProperty(_watch$n, rotationZ, function (z) {
      if (this[rotation] === euler) this[inst].rotation.z = z;else if (this[rotation] === quaternion) this[inst].quaternion.z = z;
    }), _defineProperty(_watch$n, rotationW, function (w) {
      if (this[rotation] === quaternion) this[inst].quaternion.w = w;
    }), _defineProperty(_watch$n, rotationOrder, function (order) {
      if (this[rotation] === euler) this[inst].rotation.order = chars(order).join('');
    }), _defineProperty(_watch$n, lookAtX, function (x) {
      if (this[rotation] === lookAt) this[inst].lookAt(x, this[lookAtY], this[lookAtZ]);
    }), _defineProperty(_watch$n, lookAtY, function (y) {
      if (this[rotation] === lookAt) this[inst].lookAt(this[lookAtX], y, this[lookAtZ]);
    }), _defineProperty(_watch$n, lookAtZ, function (z) {
      if (this[rotation] === lookAt) this[inst].lookAt(this[lookAtX], this[lookAtY], z);
    }), _defineProperty(_watch$n, scaleX, {
      handler: function handler(x) {
        this[inst].scale.x = x;
      },
      immediate: true
    }), _defineProperty(_watch$n, scaleY, {
      handler: function handler(y) {
        this[inst].scale.y = y;
      },
      immediate: true
    }), _defineProperty(_watch$n, scaleZ, {
      handler: function handler(z) {
        this[inst].scale.z = z;
      },
      immediate: true
    }), _defineProperty(_watch$n, castShadow, {
      handler: function handler(cs) {
        this[inst].castShadow = cs;
      },
      immediate: true
    }), _defineProperty(_watch$n, receiveShadow, {
      handler: function handler(rs) {
        this[inst].receiveShadow = rs;
      },
      immediate: true
    }), _defineProperty(_watch$n, hidden, {
      handler: function handler(h) {
        this[inst].visible = !h;
      },
      immediate: true
    }), _watch$n),
    methods: (_methods$o = {}, _defineProperty(_methods$o, add, function (slot, obj) {
      if (slot === 'default') this[inst].add(obj);
    }), _defineProperty(_methods$o, remove, function (slot, obj) {
      if (slot === 'default') this[inst].remove(obj);
    }), _methods$o),

    /**
     * Objects defined in the slot will be handled as decsendants.
     * @slot default
     */
    render: undefined
  };

  /**
   * An abstract camera component.
   */

  var VglCamera = {
    extends: VglObject3d,
    computed: _defineProperty({}, inst, function () {
      return new three.Camera();
    })
  };

  var _props$z, _watch$m;

  function assign$1(obj, assigns) {
    var _Object$assign = Object.assign(obj, assigns),
        l = _Object$assign.left,
        r = _Object$assign.right,
        t = _Object$assign.top,
        b = _Object$assign.bottom;

    if ([l, r, t, b].includes(undefined)) return;
    obj.updateProjectionMatrix();
  }
  /**
   * This camera projects the objects into constant size regardless of the distance.
   *
   * When more than 1 props of `left`, `right`, `top` or `bottom` are set, the camera frustum side
   * planes will be at specified coordinates. Otherwise they will be automatically set to fit the
   * canvas size.
   */


  var vglOrthographicCamera = {
    extends: VglCamera,
    props: (_props$z = {}, _defineProperty(_props$z, zoom, {
      type: Number,
      default: 1
    }), _defineProperty(_props$z, near, {
      type: Number,
      default: 0.1
    }), _defineProperty(_props$z, far, {
      type: Number,
      default: 2000
    }), _defineProperty(_props$z, left, Number), _defineProperty(_props$z, right, Number), _defineProperty(_props$z, top, Number), _defineProperty(_props$z, bottom, Number), _props$z),
    computed: _defineProperty({}, inst, function () {
      return new three.OrthographicCamera();
    }),
    watch: (_watch$m = {}, _defineProperty(_watch$m, zoom, {
      handler: function handler(z) {
        assign$1(this[inst], {
          zoom: z
        });
      },
      immediate: true
    }), _defineProperty(_watch$m, near, {
      handler: function handler(n) {
        assign$1(this[inst], {
          near: n
        });
      },
      immediate: true
    }), _defineProperty(_watch$m, far, {
      handler: function handler(f) {
        assign$1(this[inst], {
          far: f
        });
      },
      immediate: true
    }), _defineProperty(_watch$m, left, {
      handler: function handler(l) {
        assign$1(this[inst], {
          left: l
        });
      },
      immediate: true
    }), _defineProperty(_watch$m, right, {
      handler: function handler(r) {
        assign$1(this[inst], {
          right: r
        });
      },
      immediate: true
    }), _defineProperty(_watch$m, top, {
      handler: function handler(t) {
        assign$1(this[inst], {
          top: t
        });
      },
      immediate: true
    }), _defineProperty(_watch$m, bottom, {
      handler: function handler(b) {
        assign$1(this[inst], {
          bottom: b
        });
      },
      immediate: true
    }), _watch$m)
  };

  var _props$y, _watch$l;

  function assign(obj, assigns) {
    var _Object$assign = Object.assign(obj, assigns),
        a = _Object$assign.aspect;

    if (a !== undefined) obj.updateProjectionMatrix();
  }
  /**
   * This camera mimics the human eyes sight.
   *
   * When the `aspect` prop is omitted, it will be automatically set to fit the canvas size.
   */


  var vglPerspectiveCamera = {
    extends: VglCamera,
    props: (_props$y = {}, _defineProperty(_props$y, zoom, {
      type: Number,
      default: 1
    }), _defineProperty(_props$y, near, {
      type: Number,
      default: 0.1
    }), _defineProperty(_props$y, far, {
      type: Number,
      default: 2000
    }), _defineProperty(_props$y, fov, {
      type: Number,
      default: 50
    }), _defineProperty(_props$y, aspect, Number), _props$y),
    computed: _defineProperty({}, inst, function () {
      return new three.PerspectiveCamera();
    }),
    watch: (_watch$l = {}, _defineProperty(_watch$l, zoom, {
      handler: function handler(z) {
        assign(this[inst], {
          zoom: z
        });
      },
      immediate: true
    }), _defineProperty(_watch$l, near, {
      handler: function handler(n) {
        assign(this[inst], {
          near: n
        });
      },
      immediate: true
    }), _defineProperty(_watch$l, far, {
      handler: function handler(f) {
        assign(this[inst], {
          far: f
        });
      },
      immediate: true
    }), _defineProperty(_watch$l, fov, {
      handler: function handler(f) {
        assign(this[inst], {
          fov: f
        });
      },
      immediate: true
    }), _defineProperty(_watch$l, aspect, {
      handler: function handler(a) {
        assign(this[inst], {
          aspect: a
        });
      },
      immediate: true
    }), _watch$l)
  };

  var _methods$n;
  /**
   * This component registers reusable resources (attributes, geometries, materials, textures, etc.)
   * to the root Vue instance (as a `$_vglDefs` property) and makes them to be callable at
   * anywhere. To call registered resources, put the `vgl-use` component there.
   *
   * Note that objects (lights, lines, meshes, etc.) are unique so that they cannot be used multiple
   * times as other object's children. However, this restriction does not exist outside object tree.
   * For instance, lights cannot be added to more than one scene but a scene can be shared between
   * multiple renderers.
   */

  var vglDefs = {
    extends: VglSlotHolder,
    beforeCreate: function beforeCreate() {
      if (this.$root.$_vglDefs) this.$root.$_vglDefs.defs += 1;else {
        this.$root.$_vglDefs = {
          defs: 1,
          use: 0,
          slots: Object.create(null),
          users: Object.create(null)
        };
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.$root.$_vglDefs.defs -= 1;
      if (!this.$root.$_vglDefs.defs && !this.$root.$_vglDefs.use) delete this.$root.$_vglDefs;
    },
    methods: (_methods$n = {}, _defineProperty(_methods$n, add, function (slot, obj) {
      if (this.$root.$_vglDefs.slots[slot]) this.$root.$_vglDefs.slots[slot].push(obj);else this.$root.$_vglDefs.slots[slot] = [obj];

      if (this.$root.$_vglDefs.users[slot]) {
        this.$root.$_vglDefs.users[slot].forEach(function (user) {
          user.$_vglSlot.$emit(add, obj);
        });
      }
    }), _defineProperty(_methods$n, remove, function (slot, obj) {
      if (this.$root.$_vglDefs.users[slot]) {
        this.$root.$_vglDefs.users[slot].forEach(function (user) {
          user.$_vglSlot.$emit(remove, obj);
        });
      }

      this.$root.$_vglDefs.slots[slot].splice(this.$root.$_vglDefs.slots[slot].indexOf(obj), 1);
      if (!this.$root.$_vglDefs.slots[slot].length) delete this.$root.$_vglDefs.slots[slot];
    }), _defineProperty(_methods$n, change, function (slot) {
      if (this.$root.$_vglDefs.users[slot]) {
        this.$root.$_vglDefs.users[slot].forEach(function (user) {
          user.$_vglSlot.$emit(change);
        });
      }
    }), _methods$n),

    /**
     * Resources defined in each named slot can be reffered from the `vgl-use` component by the name.
     * @slot Any
     */
    render: undefined
  };

  var _props$x, _computed$3, _watch$k;
  var usages = {
    staticDraw: three.StaticDrawUsage,
    staticRead: three.StaticReadUsage,
    staticCopy: three.StaticCopyUsage,
    dynamicDraw: three.DynamicDrawUsage,
    dynamicRead: three.DynamicReadUsage,
    dynamicCopy: three.DynamicCopyUsage,
    streamDraw: three.StreamDrawUsage,
    streamRead: three.StreamReadUsage,
    streamCopy: three.StreamCopyUsage
  };
  var VglAttribute = {
    extends: VglSlotable,
    props: (_props$x = {}, _defineProperty(_props$x, array, {
      type: Array,
      default: function _default() {
        return [];
      },
      validator: function validator(a) {
        return a.every(function (e) {
          return typeof e === 'number' || e instanceof Number;
        });
      }
    }), _defineProperty(_props$x, name, {
      default: '',
      type: String
    }), _defineProperty(_props$x, normalized, Boolean), _defineProperty(_props$x, itemSize, {
      required: true,
      type: Number,
      validator: Number.isInteger
    }), _defineProperty(_props$x, usage, {
      default: 'staticDraw',
      type: String,
      validator: function validator(u) {
        return u in usages;
      }
    }), _props$x),
    computed: (_computed$3 = {}, _defineProperty(_computed$3, inst, function () {
      return new three.BufferAttribute(this.typedArray, this[itemSize]);
    }), _defineProperty(_computed$3, "arrayLength", function arrayLength() {
      return this.array.length;
    }), _computed$3),
    watch: (_watch$k = {}, _defineProperty(_watch$k, array, {
      handler: function handler(a) {
        this[inst].set(a);
      },
      immediate: true
    }), _defineProperty(_watch$k, normalized, {
      handler: function handler(n) {
        this[inst].normalized = n;
      },
      immediate: true
    }), _defineProperty(_watch$k, usage, {
      handler: function handler(u) {
        this[inst].setUsage(usages[u]);
      },
      immediate: true
    }), _defineProperty(_watch$k, name, {
      handler: function handler(n) {
        this[inst].name = n;
      },
      immediate: true
    }), _defineProperty(_watch$k, inst, function (obj, _ref) {
      var n = _ref.name,
          d = _ref.normalized,
          u = _ref.usage;
      Object.assign(obj, {
        name: n,
        normalized: d
      }).setUsage(u);
    }), _watch$k),
    render: function render() {}
  };

  /** The 32-bit float data store for an attribute. */

  var vglFloat32Attribute = {
    extends: VglAttribute,
    computed: {
      /** The TypedArray instance. */
      typedArray: function typedArray() {
        return new Float32Array(this.arrayLength);
      }
    }
  };

  /** The 64-bit float data store for an attribute. */

  var vglFloat64Attribute = {
    extends: VglAttribute,
    computed: {
      /** The TypedArray instance. */
      typedArray: function typedArray() {
        return new Float64Array(this.arrayLength);
      }
    }
  };

  var _props$w, _computed$2, _watch$j, _methods$m;
  /** A mesh, line, or point geometry representation. */

  var VglGeometry = {
    mixins: [VglSlotable, VglSlotHolder],
    props: (_props$w = {}, _defineProperty(_props$w, name, {
      type: String,
      default: ''
    }), _defineProperty(_props$w, drawRangeStart, {
      type: Number,
      default: 0,
      validator: Number.isInteger
    }), _defineProperty(_props$w, drawRangeCount, {
      type: Number,
      default: Infinity,
      validator: function validator(c) {
        return Number.isInteger(c) || c === Infinity;
      }
    }), _defineProperty(_props$w, groups, {
      type: Array,
      default: function _default() {
        return [];
      },
      validator: function validator(g) {
        return g.every(function (_ref) {
          var start = _ref.start,
              count = _ref.count,
              materialIndex = _ref.materialIndex;
          return [start, count, materialIndex].every(Number.isInteger);
        });
      }
    }), _props$w),
    computed: (_computed$2 = {}, _defineProperty(_computed$2, inst, function () {
      return new three.BufferGeometry();
    }), _defineProperty(_computed$2, "drawRange", function drawRange() {
      return [this[drawRangeStart], this[drawRangeCount]];
    }), _computed$2),
    beforeDestroy: function beforeDestroy() {
      this[inst].dispose();
    },
    watch: (_watch$j = {}, _defineProperty(_watch$j, name, {
      handler: function handler(n) {
        this[inst].name = n;
      },
      immediate: true
    }), _defineProperty(_watch$j, groups, {
      handler: function handler(gs) {
        var _this = this;

        this[inst].clearGroups();
        gs.forEach(function (_ref2) {
          var start = _ref2.start,
              count = _ref2.count,
              materialIndex = _ref2.materialIndex;

          _this[inst].addGroup(start, count, materialIndex);
        });
      },
      immediate: true
    }), _defineProperty(_watch$j, inst, function (newObj, prevObj) {
      var n = prevObj.name,
          r = prevObj.drawRange,
          g = prevObj.groups;
      Object.assign(newObj, {
        name: n
      }).setDrawRange(r.start, r.count);
      g.forEach(function (_ref3) {
        var start = _ref3.start,
            count = _ref3.count,
            materialIndex = _ref3.materialIndex;
        newObj.addGroup(start, count, materialIndex);
      });
      prevObj.dispose();
    }), _defineProperty(_watch$j, "drawRange", {
      handler: function handler(r) {
        var _this$inst;

        (_this$inst = this[inst]).setDrawRange.apply(_this$inst, _toConsumableArray(r));
      },
      immediate: true
    }), _watch$j),
    methods: (_methods$m = {}, _defineProperty(_methods$m, add, function (slot, obj) {
      this[inst].setAttribute(slot, obj);
    }), _defineProperty(_methods$m, remove, function (slot, obj) {
      if (this[inst].getAttribute(slot) === obj) this[inst].deleteAttribute(slot);
    }), _methods$m),

    /**
     * Each attribute in a named slot will be added to the geometry with the same name as the slot.
     * @slot Any
     */
    render: undefined
  };

  /** The 8-bit integer data store for an attribute. */

  var vglInt8Attribute = {
    extends: VglAttribute,
    computed: {
      /** The TypedArray instance. */
      typedArray: function typedArray() {
        return new Int8Array(this.arrayLength);
      }
    }
  };

  /** The 16-bit integer data store for an attribute. */

  var vglInt16Attribute = {
    extends: VglAttribute,
    computed: {
      /** The TypedArray instance. */
      typedArray: function typedArray() {
        return new Int16Array(this.arrayLength);
      }
    }
  };

  /** The 32-bit integer data store for an attribute. */

  var vglInt32Attribute = {
    extends: VglAttribute,
    computed: {
      /** The TypedArray instance. */
      typedArray: function typedArray() {
        return new Int32Array(this.arrayLength);
      }
    }
  };

  /** The 8-bit unsigned integer data store for an attribute. */

  var vglUint8Attribute = {
    extends: VglAttribute,
    computed: {
      /** The TypedArray instance. */
      typedArray: function typedArray() {
        return new Uint8Array(this.arrayLength);
      }
    }
  };

  /** The 8-bit unsigned integer data store for an attribute. */

  var vglUint8ClampedAttribute = {
    extends: VglAttribute,
    computed: {
      /** The TypedArray instance. */
      typedArray: function typedArray() {
        return new Uint8ClampedArray(this.arrayLength);
      }
    }
  };

  /** The 16-bit unsigned integer data store for an attribute. */

  var vglUint16Attribute = {
    extends: VglAttribute,
    computed: {
      /** The TypedArray instance. */
      typedArray: function typedArray() {
        return new Uint16Array(this.arrayLength);
      }
    }
  };

  /** The 32-bit unsigned integer data store for an attribute. */

  var vglUint32Attribute = {
    extends: VglAttribute,
    computed: {
      /** The TypedArray instance. */
      typedArray: function typedArray() {
        return new Uint32Array(this.arrayLength);
      }
    }
  };

  /** This component behaves as other components registered by the `vgl-defs` component. */

  var vglUse = {
    inject: {
      $_vglSlot: {
        default: {
          $emit: function $emit() {}
        }
      }
    },
    props: {
      /** The reffering slot name of the `vgl-defs` component. */
      href: {
        type: String,
        required: true
      }
    },
    watch: {
      href: {
        handler: function handler(curr, prev) {
          var _this = this;

          if (prev !== undefined) {
            if (this.$root.$_vglDefs.slots[prev]) {
              this.$root.$_vglDefs.slots[prev].forEach(function (obj) {
                _this.$_vglSlot.$emit(remove, obj);
              });
            }

            this.$root.$_vglDefs.users[prev].splice(this.$root.$_vglDefs.users[prev].indexOf(this), 1);
            if (!this.$root.$_vglDefs.users[prev].length) delete this.$root.$_vglDefs.users[prev];
          }

          if (this.$root.$_vglDefs.users[curr]) this.$root.$_vglDefs.users[curr].push(this);else this.$root.$_vglDefs.users[curr] = [this];

          if (this.$root.$_vglDefs.slots[curr]) {
            this.$root.$_vglDefs.slots[curr].forEach(function (obj) {
              _this.$_vglSlot.$emit(add, obj);
            });
          }
        },
        immediate: true
      }
    },
    beforeCreate: function beforeCreate() {
      if (this.$root.$_vglDefs) this.$root.$_vglDefs.use += 1;else {
        this.$root.$_vglDefs = {
          defs: 0,
          use: 1,
          slots: Object.create(null),
          users: Object.create(null)
        };
      }
    },
    beforeDestroy: function beforeDestroy() {
      var _this2 = this;

      if (this.$root.$_vglDefs.slots[this.href]) {
        this.$root.$_vglDefs.slots[this.href].forEach(function (obj) {
          _this2.$_vglSlot.$emit(remove, obj);
        });
      }

      this.$root.$_vglDefs.users[this.href].splice(this.$root.$_vglDefs.users[this.href].indexOf(this), 1);
      if (!this.$root.$_vglDefs.users[this.href].length) delete this.$root.$_vglDefs.users[this.href];
      this.$root.$_vglDefs.use -= 1;
      if (!this.$root.$_vglDefs.defs && !this.$root.$_vglDefs.use) delete this.$root.$_vglDefs;
    },
    render: function render() {}
  };

  /**
   * The image wrapper component to be used as the resource of other components.
   */

  var vglImage = {
    extends: VglSlotable,
    props: _defineProperty({}, src, {
      type: String,
      default: ''
    }),
    computed: _defineProperty({}, inst, function () {
      var _this = this;

      var img = document.createElement('img');
      img.addEventListener('load', function () {
        _this.$_vglSlot.$emit(change);
      }, false);
      return img;
    }),
    watch: _defineProperty({}, src, {
      handler: function handler(s) {
        this.inst.src = s;
      },
      immediate: true
    }),
    render: function render() {}
  };

  var VglCurve = {
    extends: VglSlotable,
    computed: _defineProperty({}, inst, function () {
      return new three.Curve();
    }),
    render: function render() {}
  };

  var _watch$i;
  var VglCurvePath = {
    extends: VglCurve,
    props: _defineProperty({}, autoClose, Boolean),
    computed: _defineProperty({}, inst, function () {
      return new three.CurvePath();
    }),
    watch: (_watch$i = {}, _defineProperty(_watch$i, inst, function (obj, _ref) {
      var a = _ref.autoClose;
      Object.assign(obj, {
        autoClose: a
      });
    }), _defineProperty(_watch$i, autoClose, {
      handler: function handler(a) {
        this.inst.autoClose = a;
      },
      immediate: true
    }), _watch$i)
  };

  var vglFont = {
    extends: VglSlotable,
    props: _defineProperty({}, data, Object),
    computed: _defineProperty({}, inst, function () {
      return new three.Font(this[data]);
    }),
    render: function render() {}
  };

  var _computed$1;

  function chunk$1(array, chunkSize) {
    return array.reduce(function (acc, element, index) {
      if (index % chunkSize) acc[Math.floor(index / chunkSize)].push(element);else acc.push([element]);
      return acc;
    }, []);
  }

  var pathFunctions = {
    M: function M(obj, params) {
      obj.moveTo(params[params.length - 2], params[params.length - 1]);
    },
    m: function m(obj, params) {
      obj.moveTo.apply(obj, _toConsumableArray(chunk$1(params, 2).reduce(function (_ref, _ref2) {
        var _ref3 = _slicedToArray(_ref, 2),
            x = _ref3[0],
            y = _ref3[1];

        var _ref4 = _slicedToArray(_ref2, 2),
            dx = _ref4[0],
            dy = _ref4[1];

        return [x + dx, y + dy];
      }, obj.currentPoint.toArray())));
    },
    L: function L(obj, params) {
      chunk$1(params, 2).forEach(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            x = _ref6[0],
            y = _ref6[1];

        obj.lineTo(x, y);
      });
    },
    l: function l(obj, params) {
      chunk$1(params, 2).forEach(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
            dx = _ref8[0],
            dy = _ref8[1];

        obj.lineTo(obj.currentPoint.x + dx, obj.currentPoint.y + dy);
      });
    },
    H: function H(obj, params) {
      params.forEach(function (x) {
        obj.lineTo(x, obj.currentPoint.y);
      });
    },
    h: function h(obj, params) {
      params.forEach(function (dx) {
        obj.lineTo(obj.currentPoint.x + dx, obj.currentPoint.y);
      });
    },
    V: function V(obj, params) {
      params.forEach(function (y) {
        obj.lineTo(obj.currentPoint.x, y);
      });
    },
    v: function v(obj, params) {
      params.forEach(function (dy) {
        obj.lineTo(obj.currentPoint.x, obj.currentPoint.y + dy);
      });
    },
    Q: function Q(obj, params) {
      var paramArray = chunk$1(params, 4);
      paramArray.forEach(function (_ref9) {
        var _ref10 = _slicedToArray(_ref9, 4),
            cpX = _ref10[0],
            cpY = _ref10[1],
            x = _ref10[2],
            y = _ref10[3];

        obj.quadraticCurveTo(cpX, cpY, x, y);
      });

      var _paramArray = _slicedToArray(paramArray[paramArray.length - 1], 2),
          cpX = _paramArray[0],
          cpY = _paramArray[1];

      return {
        cpX: cpX,
        cpY: cpY
      };
    },
    q: function q(obj, params) {
      var paramArray = chunk$1(params, 4);
      paramArray.forEach(function (_ref11) {
        var _ref12 = _slicedToArray(_ref11, 4),
            dCpX = _ref12[0],
            dCpY = _ref12[1],
            dx = _ref12[2],
            dy = _ref12[3];

        var _obj$currentPoint = obj.currentPoint,
            x = _obj$currentPoint.x,
            y = _obj$currentPoint.y;
        obj.quadraticCurveTo(x + dCpX, y + dCpY, x + dx, y + dy);
      });

      var _paramArray2 = _slicedToArray(paramArray[paramArray.length - 1], 4),
          dCpX = _paramArray2[0],
          dCpY = _paramArray2[1],
          dx = _paramArray2[2],
          dy = _paramArray2[3];

      return {
        cpX: obj.currentPoint.x - dx + dCpX,
        cpY: obj.currentPoint.y - dy + dCpY
      };
    },
    T: function T(obj, params, ctx) {
      var _ref13 = ctx || {
        cpX: obj.currentPoint.x,
        cpY: obj.currentPoint.y
      },
          cpX = _ref13.cpX,
          cpY = _ref13.cpY;

      chunk$1(params, 2).forEach(function (_ref14) {
        var _ref15 = _slicedToArray(_ref14, 2),
            x = _ref15[0],
            y = _ref15[1];

        cpX = obj.currentPoint.x * 2 - cpX;
        cpY = obj.currentPoint.y * 2 - cpY;
        obj.quadraticCurveTo(cpX, cpY, x, y);
      });
      return {
        cpX: cpX,
        cpY: cpY
      };
    },
    t: function t(obj, params, ctx) {
      var _ref16 = ctx || {
        cpX: obj.currentPoint.x,
        cpY: obj.currentPoint.y
      },
          cpX = _ref16.cpX,
          cpY = _ref16.cpY;

      chunk$1(params, 2).forEach(function (_ref17) {
        var _ref18 = _slicedToArray(_ref17, 2),
            dx = _ref18[0],
            dy = _ref18[1];

        cpX = obj.currentPoint.x * 2 - cpX;
        cpY = obj.currentPoint.y * 2 - cpY;
        obj.quadraticCurveTo(cpX, cpY, obj.currentPoint.x + dx, obj.currentPoint.y + dy);
      });
      return {
        cpX: cpX,
        cpY: cpY
      };
    }
  };
  var pathCommands = Object.keys(pathFunctions).join('');

  function parseCommands(cmds) {
    if (!cmds.length) return [];
    return cmds.match(new RegExp("[".concat(pathCommands, "][^").concat(pathCommands, "]*"), 'g')).map(function (cmd) {
      return [cmd[0], cmd.slice(1).trim().split(/\s*,\s*|\s+/).map(parseFloat)];
    });
  }

  var VglPath = {
    extends: VglCurvePath,
    props: _defineProperty({}, d, {
      type: String,
      default: '',
      validator: function validator(v) {
        var trimed = v.trim();
        if (!trimed.length) return true;
        if (!pathCommands.includes(trimed[0])) return false;
        return parseCommands(v).every(function (_ref19) {
          var _ref20 = _slicedToArray(_ref19, 2),
              cmd = _ref20[0],
              params = _ref20[1];

          if (params.some(Number.isNaN)) return false;
          if ('MmLlTt'.includes(cmd)) return !(params.length % 2);
          if ('Qq'.includes(cmd)) return !(params.length % 4);
          return true;
        });
      }
    }),
    computed: (_computed$1 = {}, _defineProperty(_computed$1, inst, function () {
      return this.path(new three.Path());
    }), _defineProperty(_computed$1, "path", function path() {
      var cmds = parseCommands(this.d);
      return function (obj) {
        var ctx;
        cmds.forEach(function (_ref21) {
          var _ref22 = _slicedToArray(_ref21, 2),
              cmd = _ref22[0],
              params = _ref22[1];

          ctx = pathFunctions[cmd](obj, params, ctx);
        });
        return obj;
      };
    }), _computed$1)
  };

  var _methods$l;
  var vglShape = {
    mixins: [VglPath, VglSlotHolder],
    computed: _defineProperty({}, inst, function () {
      return this.path(new three.Shape());
    }),
    watch: _defineProperty({}, inst, function (obj, _ref) {
      var h = _ref.holes;
      Object.assign(obj, {
        holes: h
      });
    }),
    methods: (_methods$l = {}, _defineProperty(_methods$l, add, function (slot, obj) {
      if (slot === holes) this.inst.holes.push(obj);
    }), _defineProperty(_methods$l, remove, function (slot, obj) {
      if (slot === holes) this.inst.holes.splice(this.inst.holes.indexOf(obj), 1);
    }), _methods$l),

    /**
     * Paths representing lacking parts of the shape.
     * @slot holes
     */
    render: undefined
  };

  var _props$v;
  var vglBoxGeometry = {
    extends: VglGeometry,
    props: (_props$v = {}, _defineProperty(_props$v, width, {
      type: Number,
      default: 1
    }), _defineProperty(_props$v, height, {
      type: Number,
      default: 1
    }), _defineProperty(_props$v, depth, {
      type: Number,
      default: 1
    }), _defineProperty(_props$v, widthSegments, {
      type: Number,
      default: 1,
      validator: Number.isInteger
    }), _defineProperty(_props$v, heightSegments, {
      type: Number,
      default: 1,
      validator: Number.isInteger
    }), _defineProperty(_props$v, depthSegments, {
      type: Number,
      default: 1,
      validator: Number.isInteger
    }), _props$v),
    computed: {
      /** The THREE.BoxGeometry instance. */
      inst: function inst() {
        return new three.BoxGeometry(this[width], this[height], this[depth], this[widthSegments], this[heightSegments], this[depthSegments]);
      }
    }
  };

  var _props$u;
  var vglCircleGeometry = {
    extends: VglGeometry,
    props: (_props$u = {}, _defineProperty(_props$u, radius, {
      type: Number,
      default: 1
    }), _defineProperty(_props$u, segments, {
      type: Number,
      default: 8,
      validator: Number.isInteger
    }), _defineProperty(_props$u, thetaStart, {
      type: Number,
      default: 0
    }), _defineProperty(_props$u, thetaLength, {
      type: Number,
      default: Math.PI * 2
    }), _props$u),
    computed: _defineProperty({}, inst, function () {
      return new three.CircleGeometry(this[radius], this[segments], this[thetaStart], this[thetaLength]);
    })
  };

  var _props$t;
  var VglCylinderGeometry = {
    extends: VglGeometry,
    props: (_props$t = {}, _defineProperty(_props$t, radiusTop, {
      type: Number,
      default: 1
    }), _defineProperty(_props$t, radiusBottom, {
      type: Number,
      default: 1
    }), _defineProperty(_props$t, height, {
      type: Number,
      default: 1
    }), _defineProperty(_props$t, radialSegments, {
      type: Number,
      default: 8,
      validator: Number.isInteger
    }), _defineProperty(_props$t, heightSegments, {
      type: Number,
      default: 1,
      validator: Number.isInteger
    }), _defineProperty(_props$t, openEnded, Boolean), _defineProperty(_props$t, thetaStart, {
      type: Number,
      default: 0
    }), _defineProperty(_props$t, thetaLength, {
      type: Number,
      default: Math.PI * 2
    }), _props$t),
    computed: _defineProperty({}, inst, function () {
      return new three.CylinderGeometry(this[radiusTop], this[radiusBottom], this[height], this[radialSegments], this[heightSegments], this[openEnded], this[thetaStart], this[thetaLength]);
    })
  };

  var vglConeGeometry = {
    extends: VglCylinderGeometry,
    props: _defineProperty({}, radius, {
      type: Number,
      default: 1
    }),
    computed: {
      /** The THREE.ConeGeometry instance. */
      inst: function inst() {
        return new three.ConeGeometry(this[radius], this[height], this[radialSegments], this[heightSegments], this[openEnded], this[thetaStart], this[thetaLength]);
      }
    }
  };

  var _props$s;
  var VglPolyhedronGeometry = {
    extends: VglGeometry,
    props: (_props$s = {}, _defineProperty(_props$s, vertices, {
      type: Array,
      default: function _default() {
        return [];
      },
      validator: function validator(array) {
        return array.every(function (e) {
          return typeof e === 'number' || e instanceof Number;
        });
      }
    }), _defineProperty(_props$s, indices, {
      type: Array,
      default: function _default() {
        return [];
      },
      validator: function validator(a) {
        return a.every(Number.isInteger);
      }
    }), _defineProperty(_props$s, radius, {
      type: Number,
      default: 1
    }), _defineProperty(_props$s, detail, {
      type: Number,
      default: 0,
      validator: Number.isInteger
    }), _props$s),
    computed: _defineProperty({}, inst, function () {
      return new three.PolyhedronGeometry(this[vertices], this[indices], this[radius], this[detail]);
    })
  };

  var vglDodecahedronGeometry = {
    extends: VglPolyhedronGeometry,
    computed: _defineProperty({}, inst, function () {
      return new three.DodecahedronGeometry(this[radius], this[detail]);
    })
  };

  var _props$r, _methods$k;
  var VglExtrudeGeometry = {
    extends: VglGeometry,
    props: (_props$r = {}, _defineProperty(_props$r, curveSegments, {
      type: Number,
      default: 12,
      validator: Number.isInteger
    }), _defineProperty(_props$r, steps, {
      type: Number,
      default: 1,
      validator: Number.isInteger
    }), _defineProperty(_props$r, depth, {
      type: Number,
      default: 50
    }), _defineProperty(_props$r, bevelEnabled, Boolean), _defineProperty(_props$r, bevelThickness, {
      type: Number,
      default: 10
    }), _defineProperty(_props$r, bevelSize, Number), _defineProperty(_props$r, bevelOffset, {
      type: Number,
      default: 0
    }), _defineProperty(_props$r, bevelSegments, {
      type: Number,
      default: 3,
      validator: Number.isInteger
    }), _defineProperty(_props$r, uvGenerator, Object), _props$r),
    data: function data() {
      return {
        shapes: [],
        extrudePath: undefined
      };
    },
    computed: _defineProperty({}, inst, function () {
      return new three.ExtrudeGeometry(this.shapes, {
        curveSegments: this[curveSegments],
        steps: this[steps],
        depth: this[depth],
        bevelEnabled: this[bevelEnabled],
        bevelThickness: this[bevelThickness],
        bevelSize: this[bevelSize],
        bevelOffset: this[bevelOffset],
        bevelSegments: this[bevelSegments],
        extrudePath: this.extrudePath,
        UVGenerator: this[uvGenerator]
      });
    }),
    methods: (_methods$k = {}, _defineProperty(_methods$k, add, function (slot, obj) {
      if (slot === shapes) this.shapes.push(obj);else if (slot === extrudePath) this.extrudePath = obj;
    }), _defineProperty(_methods$k, remove, function (slot, obj) {
      if (slot === shapes) this.shapes.splice(this.shapes.indexOf(obj), 1);else if (slot === extrudePath && this.extrudePath === obj) this.extrudePath = undefined;
    }), _methods$k)
  };

  var vglIcosahedronGeometry = {
    extends: VglPolyhedronGeometry,
    computed: _defineProperty({}, inst, function () {
      return new three.IcosahedronGeometry(this[radius], this[detail]);
    })
  };

  var _props$q;

  function isNumber(number) {
    return typeof number === 'number' || number instanceof Number;
  }

  function chunk(array) {
    return array.reduce(function (acc, value, index) {
      if (index % 2) acc[acc.length - 1].push(value);else acc.push([value]);
      return acc;
    }, []);
  }

  var vglLatheGeometry = {
    extends: VglGeometry,
    props: (_props$q = {}, _defineProperty(_props$q, points, {
      type: Array,
      default: function _default() {
        return [];
      },
      validator: function validator(pts) {
        return pts.every(isNumber) && !(pts.length % 2) || pts.every(function (pair) {
          return Array.isArray(pair) && pair.length === 2 && pair.every(isNumber);
        });
      }
    }), _defineProperty(_props$q, segments, {
      type: Number,
      default: 12,
      validator: Number.isInteger
    }), _defineProperty(_props$q, phiStart, {
      type: Number,
      default: 0
    }), _defineProperty(_props$q, phiLength, {
      type: Number,
      default: Math.PI * 2
    }), _props$q),
    computed: _defineProperty({}, inst, function () {
      return new three.LatheGeometry(chunk(this[points].flat()).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            x = _ref2[0],
            y = _ref2[1];

        return new three.Vector2(x, y);
      }), this[segments], this[phiStart], this[phiLength]);
    })
  };

  var vglOctahedronGeometry = {
    extends: VglPolyhedronGeometry,
    computed: _defineProperty({}, inst, function () {
      return new three.OctahedronGeometry(this[radius], this[detail]);
    })
  };

  var _props$p;
  var vglPlaneGeometry = {
    extends: VglGeometry,
    props: (_props$p = {}, _defineProperty(_props$p, width, {
      type: Number,
      default: 1
    }), _defineProperty(_props$p, height, {
      type: Number,
      default: 1
    }), _defineProperty(_props$p, widthSegments, {
      type: Number,
      default: 1,
      validator: Number.isInteger
    }), _defineProperty(_props$p, heightSegments, {
      type: Number,
      default: 1,
      validator: Number.isInteger
    }), _props$p),
    computed: _defineProperty({}, inst, function () {
      return new three.PlaneGeometry(this[width], this[height], this[widthSegments], this[heightSegments]);
    })
  };

  var _props$o;
  var vglRingGeometry = {
    extends: VglGeometry,
    props: (_props$o = {}, _defineProperty(_props$o, innerRadius, {
      type: Number,
      default: 0.5
    }), _defineProperty(_props$o, outerRadius, {
      type: Number,
      default: 1
    }), _defineProperty(_props$o, thetaSegments, {
      type: Number,
      default: 8,
      validator: Number.isInteger
    }), _defineProperty(_props$o, phiSegments, {
      type: Number,
      default: 1,
      validator: Number.isInteger
    }), _defineProperty(_props$o, thetaStart, {
      type: Number,
      default: 0
    }), _defineProperty(_props$o, thetaLength, {
      type: Number,
      default: Math.PI * 2
    }), _props$o),
    computed: {
      /** The THREE.RingGeometry instance. */
      inst: function inst() {
        return new three.RingGeometry(this[innerRadius], this[outerRadius], this[thetaSegments], this[phiSegments], this[thetaStart], this[thetaLength]);
      }
    }
  };

  var _methods$j;
  var vglShapeGeometry = {
    extends: VglGeometry,
    props: _defineProperty({}, curveSegments, {
      type: Number,
      default: 12,
      validator: Number.isInteger
    }),
    data: function data() {
      return {
        shapes: []
      };
    },
    computed: _defineProperty({}, inst, function () {
      return new three.ShapeGeometry(this.shapes, this[curveSegments]);
    }),
    methods: (_methods$j = {}, _defineProperty(_methods$j, add, function (slot, obj) {
      if (slot === shapes) this.shapes.push(obj);
    }), _defineProperty(_methods$j, remove, function (slot, obj) {
      if (slot === shapes) this.shapes.splice(this.shapes.indexOf(obj), 1);
    }), _methods$j)
  };

  var _props$n;
  var vglSphereGeometry = {
    extends: VglGeometry,
    props: (_props$n = {}, _defineProperty(_props$n, radius, {
      type: Number,
      default: 1
    }), _defineProperty(_props$n, widthSegments, {
      type: Number,
      default: 8,
      validator: Number.isInteger
    }), _defineProperty(_props$n, heightSegments, {
      type: Number,
      default: 6,
      validator: Number.isInteger
    }), _defineProperty(_props$n, phiStart, {
      type: Number,
      default: 0
    }), _defineProperty(_props$n, phiLength, {
      type: Number,
      default: Math.PI * 2
    }), _defineProperty(_props$n, thetaStart, {
      type: Number,
      default: 0
    }), _defineProperty(_props$n, thetaLength, {
      type: Number,
      default: Math.PI
    }), _props$n),
    computed: _defineProperty({}, inst, function () {
      return new three.SphereGeometry(this[radius], this[widthSegments], this[heightSegments], this[phiStart], this[phiLength], this[thetaStart], this[thetaLength]);
    })
  };

  var vglTetrahedronGeometry = {
    extends: VglPolyhedronGeometry,
    computed: _defineProperty({}, inst, function () {
      return new three.TetrahedronGeometry(this[radius], this[detail]);
    })
  };

  var _props$m, _methods$i;
  var vglTextGeometry = {
    extends: VglExtrudeGeometry,
    props: (_props$m = {}, _defineProperty(_props$m, text, {
      type: String,
      default: ''
    }), _defineProperty(_props$m, size, {
      type: Number,
      default: 100
    }), _props$m),
    data: function data() {
      return {
        font: undefined
      };
    },
    computed: _defineProperty({}, inst, function () {
      if (!this.font) return new three.BufferGeometry();
      return new three.TextGeometry(this[text], {
        font: this.font,
        size: this[size],
        height: this[depth],
        curveSegments: this[curveSegments],
        steps: this[steps],
        bevelEnabled: this[bevelEnabled],
        bevelThickness: this[bevelThickness],
        bevelSize: this[bevelSize],
        bevelOffset: this[bevelOffset],
        extrudePath: this.extrudePath,
        bevelSegments: this[bevelSegments],
        UVGenerator: this[uvGenerator]
      });
    }),
    methods: (_methods$i = {}, _defineProperty(_methods$i, add, function (slot, obj) {
      if (slot === font) this.font = obj;else if (slot === extrudePath) this.extrudePath = obj;
    }), _defineProperty(_methods$i, remove, function (slot, obj) {
      if (slot === font) {
        if (this.font === obj) this.font = undefined;
      } else if (slot === extrudePath && this.extrudePath === obj) {
        this.extrudePath = undefined;
      }
    }), _methods$i)
  };

  var _props$l;
  var vglTorusGeometry = {
    extends: VglGeometry,
    props: (_props$l = {}, _defineProperty(_props$l, radius, {
      type: Number,
      default: 1
    }), _defineProperty(_props$l, tube, {
      type: Number,
      default: 0.4
    }), _defineProperty(_props$l, radialSegments, {
      type: Number,
      default: 8,
      validator: Number.isInteger
    }), _defineProperty(_props$l, tubularSegments, {
      type: Number,
      default: 6,
      validator: Number.isInteger
    }), _defineProperty(_props$l, arc, {
      type: Number,
      default: Math.PI * 2
    }), _props$l),
    computed: {
      /** The THREE.TorusGeometry instance. */
      inst: function inst() {
        return new three.TorusGeometry(this[radius], this[tube], this[radialSegments], this[tubularSegments], this[arc]);
      }
    }
  };

  var _props$k;
  var vglTorusKnotGeometry = {
    extends: VglGeometry,
    props: (_props$k = {}, _defineProperty(_props$k, radius, {
      type: Number,
      default: 1
    }), _defineProperty(_props$k, tube, {
      type: Number,
      default: 0.4
    }), _defineProperty(_props$k, radialSegments, {
      type: Number,
      default: 8,
      validator: Number.isInteger
    }), _defineProperty(_props$k, tubularSegments, {
      type: Number,
      default: 64,
      validator: Number.isInteger
    }), _defineProperty(_props$k, p, {
      type: Number,
      default: 2,
      validator: Number.isInteger
    }), _defineProperty(_props$k, q, {
      type: Number,
      default: 3,
      validator: Number.isInteger
    }), _props$k),
    computed: {
      /** The THREE.TorusKnotGeometry instance. */
      inst: function inst() {
        return new three.TorusKnotGeometry(this[radius], this[tube], this[tubularSegments], this[radialSegments], this[p], this[q]);
      }
    }
  };

  var _props$j, _watch$h;
  var vglArrowHelper = {
    extends: VglObject3d,
    props: (_props$j = {}, _defineProperty(_props$j, directionX, {
      type: Number,
      default: 0
    }), _defineProperty(_props$j, directionY, {
      type: Number,
      default: 0
    }), _defineProperty(_props$j, directionZ, {
      type: Number,
      default: 1
    }), _defineProperty(_props$j, length, {
      type: Number,
      default: 1
    }), _defineProperty(_props$j, color, {
      type: [String, Number],
      default: 0xffff00
    }), _defineProperty(_props$j, headLength, Number), _defineProperty(_props$j, headWidth, Number), _props$j),
    computed: _defineProperty({}, inst, function () {
      return new three.ArrowHelper();
    }),
    watch: (_watch$h = {}, _defineProperty(_watch$h, directionX, {
      handler: function handler(x) {
        this[inst].setDirection(new three.Vector3(x, this[directionY], this[directionZ]).normalize());
      },
      immediate: true
    }), _defineProperty(_watch$h, directionY, function (y) {
      this[inst].setDirection(new three.Vector3(this[directionX], y, this[directionZ]).normalize());
    }), _defineProperty(_watch$h, directionZ, function (z) {
      this[inst].setDirection(new three.Vector3(this[directionX], this[directionY], z).normalize());
    }), _defineProperty(_watch$h, length, {
      handler: function handler(len) {
        this[inst].setLength(len, this[headLength], this[headWidth]);
      },
      immediate: true
    }), _defineProperty(_watch$h, headLength, function (len) {
      this[inst].setLength(this[length], len, this[headWidth]);
    }), _defineProperty(_watch$h, headWidth, function (w) {
      this[inst].setLength(this[length], this[headLength], w);
    }), _defineProperty(_watch$h, color, {
      handler: function handler(c) {
        this[inst].setColor(c);
      },
      immediate: true
    }), _watch$h)
  };

  var defaultGeometry = new three.BufferGeometry();
  var defaultMeshMaterial = new three.MeshBasicMaterial();
  var defaultLineMaterial = new three.LineBasicMaterial();
  var defaultPointsMaterial = new three.PointsMaterial();
  var defaultSpriteMaterial = new three.SpriteMaterial();

  var _methods$h;
  var VglLine = {
    mixins: [VglObject3d],
    computed: _defineProperty({}, inst, function () {
      return new three.Line();
    }),
    methods: (_methods$h = {}, _defineProperty(_methods$h, add, function (slot, obj) {
      if (slot === geometry) {
        this[inst].geometry = obj;
        if (this[inst].material instanceof three.LineDashedMaterial) this[inst].computeLineDistances();
      } else if (slot === material) {
        this[inst].material = obj;
        if (obj instanceof three.LineDashedMaterial) this[inst].computeLineDistances();
      } else VglObject3d.methods[add].call(this, slot, obj);
    }), _defineProperty(_methods$h, remove, function (slot, obj) {
      if (slot === geometry) {
        if (this[inst].geometry === obj) {
          this[inst].geometry = defaultGeometry;
          if (this[inst].material instanceof three.LineDashedMaterial) this[inst].computeLineDistances();
        }
      } else if (slot === material && this[inst].material === obj) {
        this[inst].material = defaultLineMaterial;
      } else VglObject3d.methods[remove].call(this, slot, obj);
    }), _methods$h)
  };

  var VglLineSegments = {
    mixins: [VglLine],
    computed: _defineProperty({}, inst, function () {
      return new three.LineSegments();
    })
  };

  var _props$i, _computed, _watch$g;
  var vglAxesHelper = {
    extends: VglLineSegments,
    props: (_props$i = {}, _defineProperty(_props$i, size, {
      type: Number,
      default: 1
    }), _defineProperty(_props$i, xAxisColor, [String, Number]), _defineProperty(_props$i, yAxisColor, [String, Number]), _defineProperty(_props$i, zAxisColor, [String, Number]), _props$i),
    computed: (_computed = {}, _defineProperty(_computed, inst, function () {
      return new three.AxesHelper(this[size]);
    }), _defineProperty(_computed, "colors", function colors() {
      return [this[xAxisColor], this[yAxisColor], this[zAxisColor]];
    }), _computed),
    watch: (_watch$g = {}, _defineProperty(_watch$g, inst, function (obj, _ref) {
      var geometry = _ref.geometry;
      obj.geometry.getAttribute('color').set(geometry.getAttribute('color').array);
    }), _defineProperty(_watch$g, "colors", {
      handler: function handler(colors, prevColors) {
        var _this$inst;

        if (colors.includes(undefined)) {
          if (!prevColors) return;
          var attr = this[inst].geometry.getAttribute('color');
          attr.set([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1]);
          attr.needsUpdate = true;
        } else (_this$inst = this[inst]).setColors.apply(_this$inst, _toConsumableArray(colors));
      },
      immediate: true
    }), _watch$g),
    beforeDestroy: function beforeDestroy() {
      this[inst].dispose();
    }
  };

  function superMethod(component, name) {
    if (name in component.methods) return component.methods[name];
    if ('extends' in component) return superMethod(component.extends, name);
    return function () {};
  }

  var _methods$g;
  var vglBoxHelper = {
    extends: VglLineSegments,
    props: _defineProperty({}, color, {
      type: [String, Number],
      default: 0xffff00
    }),
    computed: _defineProperty({}, inst, function () {
      return new three.BoxHelper();
    }),
    watch: _defineProperty({}, color, {
      handler: function handler(c) {
        this.inst.material.color.set(c);
      },
      immediate: true
    }),
    methods: (_methods$g = {}, _defineProperty(_methods$g, add, function (slot, obj) {
      var _this = this;

      if (slot === object) this.$nextTick(function () {
        _this[inst].setFromObject(obj);
      });else superMethod(VglLineSegments, add).call(this, slot, obj);
    }), _defineProperty(_methods$g, remove, function (slot, obj) {
      var _this2 = this;

      if (slot === object) {
        this.$nextTick(function () {
          if (_this2.object === obj) _this2[inst].object = undefined;
        });
      } else superMethod(VglLineSegments, remove).call(this, slot, obj);
    }), _defineProperty(_methods$g, change, function (slot) {
      var _this3 = this;

      if (slot === object) this.$nextTick(function () {
        _this3[inst].update();
      });else superMethod(VglLineSegments, change).call(this, slot);
    }), _methods$g),

    /**
     * @slot object
     */
    render: undefined
  };

  var _methods$f;
  var vglCameraHelper = {
    extends: VglLineSegments,
    data: function data() {
      return {
        camera: null
      };
    },
    computed: _defineProperty({}, inst, function () {
      return this.camera ? new three.CameraHelper(this.camera) : new three.LineSegments();
    }),
    methods: (_methods$f = {}, _defineProperty(_methods$f, add, function (slot, obj) {
      if (slot === camera) this.camera = obj;else superMethod(VglLineSegments, add).call(this, slot, obj);
    }), _defineProperty(_methods$f, remove, function (slot, obj) {
      if (slot === camera) {
        if (this.camera === obj) this.camera = null;
      } else superMethod(VglLineSegments, remove).call(this, slot, obj);
    }), _methods$f)
  };

  var _props$h, _methods$e, _watch$f;
  var vglDirectionalLightHelper = {
    extends: VglObject3d,
    props: (_props$h = {}, _defineProperty(_props$h, color, [String, Number]), _defineProperty(_props$h, size, {
      type: Number,
      default: 1
    }), _props$h),
    beforeDestroy: function beforeDestroy() {
      this[inst].dispose();
    },
    data: function data() {
      return {
        light: null
      };
    },
    computed: _defineProperty({}, inst, function () {
      return this.light ? new three.DirectionalLightHelper(this.light, this[size]) : new three.Object3D();
    }),
    methods: (_methods$e = {}, _defineProperty(_methods$e, add, function (slot, obj) {
      if (slot === light) this.light = obj;else VglObject3d.methods[add].call(this, slot, obj);
    }), _defineProperty(_methods$e, remove, function (slot, obj) {
      if (slot === light) {
        if (this.light === obj) this.light = null;
      } else VglObject3d.methods[remove].call(this, slot, obj);
    }), _methods$e),
    watch: (_watch$f = {}, _defineProperty(_watch$f, inst, function (obj, _ref) {
      var c = _ref.color;
      Object.assign(obj, {
        color: c
      }).update();
    }), _defineProperty(_watch$f, color, {
      handler: function handler(c) {
        if (!this.light) return;
        this[inst].color = c;
        this[inst].update();
      },
      immediate: true
    }), _watch$f)
  };

  var _props$g;
  var vglGridHelper = {
    extends: VglLineSegments,
    props: (_props$g = {}, _defineProperty(_props$g, size, {
      type: Number,
      default: 10
    }), _defineProperty(_props$g, divisions, {
      type: Number,
      default: 10,
      validator: Number.isInteger
    }), _defineProperty(_props$g, colorCenterLine, {
      type: [String, Number],
      default: 0x444444
    }), _defineProperty(_props$g, colorGrid, {
      type: [String, Number],
      default: 0x888888
    }), _props$g),
    computed: _defineProperty({}, inst, function () {
      return new three.GridHelper(this[size], this[divisions], this[colorCenterLine], this[colorGrid]);
    })
  };

  var _props$f;
  var vglPolarGridHelper = {
    extends: VglLineSegments,
    props: (_props$f = {}, _defineProperty(_props$f, radius, {
      type: Number,
      default: 10
    }), _defineProperty(_props$f, radials, {
      type: Number,
      default: 16,
      validator: Number.isInteger
    }), _defineProperty(_props$f, circles, {
      type: Number,
      default: 8,
      validator: Number.isInteger
    }), _defineProperty(_props$f, divisions, {
      type: Number,
      default: 64,
      validator: Number.isInteger
    }), _defineProperty(_props$f, color1, {
      type: [String, Number],
      default: 0x444444
    }), _defineProperty(_props$f, color2, {
      type: [String, Number],
      default: 0x888888
    }), _props$f),
    computed: _defineProperty({}, inst, function () {
      return new three.PolarGridHelper(this[radius], this[radials], this[circles], this[divisions], this[color1], this[color2]);
    })
  };

  var _methods$d, _watch$e;
  var vglSpotLightHelper = {
    extends: VglObject3d,
    props: _defineProperty({}, color, [String, Number]),
    data: function data() {
      return {
        lightUuid: null
      };
    },
    computed: _defineProperty({}, inst, function () {
      return this.lightUuid ? new three.SpotLightHelper(this.light) : new three.Object3D();
    }),
    methods: (_methods$d = {}, _defineProperty(_methods$d, add, function (slot, obj) {
      if (slot === light) {
        this.light = obj;
        this.lightUuid = obj.uuid;
      } else superMethod(VglObject3d, add).call(this, slot, obj);
    }), _defineProperty(_methods$d, remove, function (slot, obj) {
      if (slot === light) {
        if (this.light === obj) {
          delete this.light;
          this.lightUuid = null;
        }
      } else superMethod(VglObject3d, remove).call(this, slot, obj);
    }), _defineProperty(_methods$d, change, function (slot) {
      if (slot === light) this[inst].update();
      superMethod(VglObject3d, change).call(this, slot);
    }), _methods$d),
    watch: (_watch$e = {}, _defineProperty(_watch$e, inst, function (obj, _ref) {
      var c = _ref.color;
      Object.assign(obj, {
        color: c
      }).update();
    }), _defineProperty(_watch$e, color, {
      handler: function handler(c) {
        if (this.light) Object.assign(this[inst], {
          color: c
        }).update();
      },
      immediate: true
    }), _watch$e)
  };

  var _props$e, _watch$d;
  var VglLight = {
    extends: VglObject3d,
    props: (_props$e = {}, _defineProperty(_props$e, color, {
      type: [String, Number],
      default: 0xffffff
    }), _defineProperty(_props$e, intensity, {
      type: Number,
      default: 1
    }), _props$e),
    computed: _defineProperty({}, inst, function () {
      return new three.Light();
    }),
    watch: (_watch$d = {}, _defineProperty(_watch$d, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }), _defineProperty(_watch$d, intensity, {
      handler: function handler(i) {
        this[inst].intensity = i;
      },
      immediate: true
    }), _watch$d),
    beforeDestroy: function beforeDestroy() {
      this[inst].dispose();
    }
  };

  var vglAmbientLight = {
    extends: VglLight,
    computed: _defineProperty({}, inst, function () {
      return new three.AmbientLight();
    })
  };

  var vglDirectionalLight = {
    extends: VglLight,
    computed: _defineProperty({}, inst, function () {
      return new three.DirectionalLight();
    })
  };

  var vglHemisphereLight = {
    extends: VglLight,
    props: _defineProperty({}, groundColor, {
      type: [String, Number],
      default: 0xffffff
    }),
    computed: _defineProperty({}, inst, function () {
      return new three.HemisphereLight();
    }),
    watch: _defineProperty({}, groundColor, {
      handler: function handler(c) {
        this[inst].groundColor.set(c);
      },
      immediate: true
    })
  };

  var _props$d, _watch$c;
  var vglPointLight = {
    extends: VglLight,
    props: (_props$d = {}, _defineProperty(_props$d, distance, {
      type: Number,
      default: 0
    }), _defineProperty(_props$d, decay, {
      type: Number,
      default: 1
    }), _props$d),
    computed: _defineProperty({}, inst, function () {
      return new three.PointLight();
    }),
    watch: (_watch$c = {}, _defineProperty(_watch$c, distance, {
      handler: function handler(d) {
        this[inst].distance = d;
      },
      immediate: true
    }), _defineProperty(_watch$c, decay, {
      handler: function handler(d) {
        this[inst].decay = d;
      },
      immediate: true
    }), _watch$c)
  };

  var _props$c, _watch$b;
  var vglRectAreaLight = {
    extends: VglLight,
    props: (_props$c = {}, _defineProperty(_props$c, width, {
      type: Number,
      default: 10
    }), _defineProperty(_props$c, height, {
      type: Number,
      default: 10
    }), _props$c),
    computed: _defineProperty({}, inst, function () {
      return new three.RectAreaLight();
    }),
    watch: (_watch$b = {}, _defineProperty(_watch$b, width, {
      handler: function handler(w) {
        this[inst].width = w;
      },
      immediate: true
    }), _defineProperty(_watch$b, height, {
      handler: function handler(h) {
        this[inst].height = h;
      },
      immediate: true
    }), _watch$b)
  };

  var _props$b, _watch$a, _methods$c;
  var vglSpotLight = {
    extends: VglLight,
    props: (_props$b = {}, _defineProperty(_props$b, distance, {
      type: Number,
      default: 0
    }), _defineProperty(_props$b, decay, {
      type: Number,
      default: 1
    }), _defineProperty(_props$b, angle, {
      type: Number,
      default: Math.PI / 3,
      validator: function validator(a) {
        return a >= 0 && a <= Math.PI / 2;
      }
    }), _defineProperty(_props$b, penumbra, {
      type: Number,
      default: 0,
      validator: function validator(n) {
        return n >= 0 && n <= 1;
      }
    }), _props$b),
    computed: _defineProperty({}, inst, function () {
      return new three.SpotLight();
    }),
    watch: (_watch$a = {}, _defineProperty(_watch$a, distance, {
      handler: function handler(d) {
        this[inst].distance = d;
      },
      immediate: true
    }), _defineProperty(_watch$a, decay, {
      handler: function handler(d) {
        this[inst].decay = d;
      },
      immediate: true
    }), _defineProperty(_watch$a, angle, {
      handler: function handler(a) {
        this[inst].angle = a;
      },
      immediate: true
    }), _defineProperty(_watch$a, penumbra, {
      handler: function handler(p) {
        this[inst].penumbra = p;
      },
      immediate: true
    }), _watch$a),
    methods: (_methods$c = {}, _defineProperty(_methods$c, add, function (slot, obj) {
      if (slot === target) this[inst].target = obj;else superMethod(VglLight, add).call(this, slot, obj);
    }), _defineProperty(_methods$c, remove, function (slot, obj) {
      if (slot === target) {
        if (this[inst].target === obj) this[inst].target = new three.Object3D();
      } else superMethod(VglLight, remove).call(this, slot, obj);
    }), _methods$c)
  };

  var _props$a, _watch$9;
  var sides = {
    front: three.FrontSide,
    back: three.BackSide,
    double: three.DoubleSide
  };
  var VglMaterial = {
    mixins: [VglSlotable, VglSlotHolder],
    props: (_props$a = {}, _defineProperty(_props$a, name, {
      type: String,
      default: ''
    }), _defineProperty(_props$a, side, {
      type: String,
      default: 'front',
      validator: function validator(s) {
        return s in sides;
      }
    }), _defineProperty(_props$a, vertexColors, Boolean), _defineProperty(_props$a, defines, {
      type: Object,
      default: function _default() {
        return {};
      }
    }), _defineProperty(_props$a, fog, Boolean), _props$a),
    computed: _defineProperty({}, inst, function () {
      return new three.Material();
    }),
    watch: (_watch$9 = {}, _defineProperty(_watch$9, name, {
      handler: function handler(n) {
        this[inst].name = n;
      },
      immediate: true
    }), _defineProperty(_watch$9, side, {
      handler: function handler(s) {
        this[inst].side = sides[s];
      },
      immediate: true
    }), _defineProperty(_watch$9, vertexColors, {
      handler: function handler(c) {
        this[inst].vertexColors = c;
      },
      immediate: true
    }), _defineProperty(_watch$9, defines, {
      handler: function handler(d) {
        Object.assign(this[inst], {
          defines: d,
          needsUpdate: true
        });
      },
      immediate: true
    }), _defineProperty(_watch$9, fog, {
      handler: function handler(f) {
        Object.assign(this[inst], {
          fog: f,
          needsUpdate: true
        });
      },
      immediate: true
    }), _watch$9),
    beforeDestroy: function beforeDestroy() {
      this[inst].dispose();
    }
  };

  var _props$9, _watch$8;
  var vglLineBasicMaterial = {
    mixins: [VglMaterial],
    props: (_props$9 = {}, _defineProperty(_props$9, color, {
      type: [String, Number],
      default: 0xffffff
    }), _defineProperty(_props$9, linewidth, {
      type: Number,
      default: 1
    }), _defineProperty(_props$9, linecap, {
      type: String,
      default: 'round',
      validator: function validator(v) {
        return ['butt', 'round', 'square'].includes(v);
      }
    }), _defineProperty(_props$9, linejoin, {
      type: String,
      default: 'round',
      validator: function validator(v) {
        return ['round', 'bevel', 'miter'].includes(v);
      }
    }), _props$9),
    computed: _defineProperty({}, inst, function () {
      return new three.LineBasicMaterial();
    }),
    watch: (_watch$8 = {}, _defineProperty(_watch$8, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }), _defineProperty(_watch$8, linewidth, {
      handler: function handler(w) {
        this[inst].linewidth = w;
      },
      immediate: true
    }), _defineProperty(_watch$8, linecap, {
      handler: function handler(c) {
        this[inst].linecap = c;
      },
      immediate: true
    }), _defineProperty(_watch$8, linejoin, {
      handler: function handler(j) {
        this[inst].linejoin = j;
      },
      immediate: true
    }), _watch$8)
  };

  var _props$8, _watch$7;
  var vglLineDashedMaterial = {
    mixins: [VglMaterial],
    props: (_props$8 = {}, _defineProperty(_props$8, color, {
      type: [String, Number],
      default: 0xffffff
    }), _defineProperty(_props$8, linewidth, {
      type: Number,
      default: 1
    }), _defineProperty(_props$8, dashSize, {
      type: Number,
      default: 3
    }), _defineProperty(_props$8, gapSize, {
      type: Number,
      default: 1
    }), _props$8),
    computed: _defineProperty({}, inst, function () {
      return new three.LineDashedMaterial();
    }),
    watch: (_watch$7 = {}, _defineProperty(_watch$7, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }), _defineProperty(_watch$7, linewidth, {
      handler: function handler(w) {
        this[inst].linewidth = w;
      },
      immediate: true
    }), _defineProperty(_watch$7, dashSize, {
      handler: function handler(s) {
        this[inst].dashSize = s;
      },
      immediate: true
    }), _defineProperty(_watch$7, gapSize, {
      handler: function handler(s) {
        this[inst].gapSize = s;
      },
      immediate: true
    }), _watch$7)
  };

  var _methods$b;
  var vglMeshBasicMaterial = {
    mixins: [VglMaterial],
    props: _defineProperty({}, color, {
      type: [String, Number],
      default: 0xffffff
    }),
    computed: _defineProperty({}, inst, function () {
      return new three.MeshBasicMaterial();
    }),
    watch: _defineProperty({}, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }),
    methods: (_methods$b = {}, _defineProperty(_methods$b, add, function (slot, obj) {
      if (slot === map) this[inst].map = obj;
    }), _defineProperty(_methods$b, remove, function (slot, obj) {
      if (slot === map && this[inst].map === obj) this[inst].map = null;
    }), _methods$b)
  };

  var _methods$a;
  var vglMeshDepthMaterial = {
    mixins: [VglMaterial],
    props: _defineProperty({}, fog, Boolean),
    computed: _defineProperty({}, inst, function () {
      return new three.MeshDepthMaterial();
    }),
    watch: _defineProperty({}, fog, {
      handler: function handler(f) {
        this[inst].fog = f;
      },
      immediate: true
    }),
    methods: (_methods$a = {}, _defineProperty(_methods$a, add, function (slot, obj) {
      if (slot === map) this[inst].map = obj;
    }), _defineProperty(_methods$a, remove, function (slot, obj) {
      if (slot === map && this[inst].map === obj) this[inst].map = null;
    }), _methods$a)
  };

  var _methods$9;
  var vglMeshLambertMaterial = {
    mixins: [VglMaterial],
    props: _defineProperty({}, color, {
      type: [String, Number],
      default: 0xffffff
    }),
    computed: _defineProperty({}, inst, function () {
      return new three.MeshLambertMaterial();
    }),
    watch: _defineProperty({}, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }),
    methods: (_methods$9 = {}, _defineProperty(_methods$9, add, function (slot, obj) {
      if (slot === map) this[inst].map = obj;
    }), _defineProperty(_methods$9, remove, function (slot, obj) {
      if (slot === map && this[inst].map === obj) this[inst].map = null;
    }), _methods$9)
  };

  var vglMeshNormalMaterial = {
    mixins: [VglMaterial],
    props: _defineProperty({}, fog, Boolean),
    computed: _defineProperty({}, inst, function () {
      return new three.MeshNormalMaterial();
    }),
    watch: _defineProperty({}, fog, {
      handler: function handler(f) {
        this[inst].fog = f;
      },
      immediate: true
    })
  };

  var _props$7, _watch$6, _methods$8;
  var vglMeshPhongMaterial = {
    mixins: [VglMaterial],
    props: (_props$7 = {}, _defineProperty(_props$7, color, {
      type: [String, Number],
      default: 0xffffff
    }), _defineProperty(_props$7, specular, {
      type: [String, Number],
      default: 0x111111
    }), _defineProperty(_props$7, shininess, {
      type: Number,
      default: 30
    }), _props$7),
    computed: _defineProperty({}, inst, function () {
      return new three.MeshPhongMaterial();
    }),
    watch: (_watch$6 = {}, _defineProperty(_watch$6, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }), _defineProperty(_watch$6, specular, {
      handler: function handler(s) {
        this[inst].specular.set(s);
      },
      immediate: true
    }), _defineProperty(_watch$6, shininess, {
      handler: function handler(s) {
        this[inst].shininess = s;
      },
      immediate: true
    }), _watch$6),
    methods: (_methods$8 = {}, _defineProperty(_methods$8, add, function (slot, obj) {
      if (slot === map) this[inst].map = obj;
    }), _defineProperty(_methods$8, remove, function (slot, obj) {
      if (slot === map && this[inst].map === obj) this[inst].map = null;
    }), _methods$8)
  };

  var _methods$7;
  var VglMeshStandardMaterial = {
    mixins: [VglMaterial],
    props: _defineProperty({}, color, {
      type: [String, Number],
      default: 0xffffff
    }),
    computed: _defineProperty({}, inst, function () {
      return new three.MeshStandardMaterial();
    }),
    watch: _defineProperty({}, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }),
    methods: (_methods$7 = {}, _defineProperty(_methods$7, add, function (slot, obj) {
      if (slot === map) this[inst].map = obj;
    }), _defineProperty(_methods$7, remove, function (slot, obj) {
      if (slot === map && this[inst].map === obj) this[inst].map = null;
    }), _methods$7),

    /**
     * @slot map
     */
    render: undefined
  };

  var _props$6, _watch$5;
  var vglMeshPhysicalMaterial = {
    mixins: [VglMeshStandardMaterial],
    props: (_props$6 = {}, _defineProperty(_props$6, clearcoat, {
      type: Number,
      default: 0,
      validator: function validator(v) {
        return v >= 0 && v <= 1;
      }
    }), _defineProperty(_props$6, clearcoatRoughness, {
      type: Number,
      default: 0,
      validator: function validator(v) {
        return v >= 0 && v <= 1;
      }
    }), _defineProperty(_props$6, reflectivity, {
      type: Number,
      default: 0.5,
      validator: function validator(v) {
        return v >= 0 && v <= 1;
      }
    }), _props$6),
    computed: _defineProperty({}, inst, function () {
      return new three.MeshPhysicalMaterial();
    }),
    watch: (_watch$5 = {}, _defineProperty(_watch$5, clearcoat, {
      handler: function handler(c) {
        this[inst].clearcoat = c;
      },
      immediate: true
    }), _defineProperty(_watch$5, clearcoatRoughness, {
      handler: function handler(r) {
        this[inst].clearcoatRoughness = r;
      },
      immediate: true
    }), _defineProperty(_watch$5, reflectivity, {
      handler: function handler(r) {
        this[inst].reflectivity = r;
      },
      immediate: true
    }), _watch$5)
  };

  var _methods$6;
  var vglMeshToonMaterial = {
    mixins: [VglMaterial],
    props: _defineProperty({}, color, {
      type: [String, Number],
      default: 0xffffff
    }),
    computed: _defineProperty({}, inst, function () {
      return new three.MeshToonMaterial();
    }),
    watch: _defineProperty({}, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }),
    methods: (_methods$6 = {}, _defineProperty(_methods$6, add, function (slot, obj) {
      if (slot === map) this[inst].map = obj;
    }), _defineProperty(_methods$6, remove, function (slot, obj) {
      if (slot === map && this[inst].map === obj) this[inst].map = null;
    }), _methods$6)
  };

  var _props$5, _watch$4;
  var vglPointsMaterial = {
    mixins: [VglMaterial],
    props: (_props$5 = {}, _defineProperty(_props$5, color, {
      type: [String, Number],
      default: 0xffffff
    }), _defineProperty(_props$5, size, {
      type: Number,
      default: 1
    }), _defineProperty(_props$5, noSizeAttenuation, Boolean), _props$5),
    computed: _defineProperty({}, inst, function () {
      return new three.PointsMaterial();
    }),
    watch: (_watch$4 = {}, _defineProperty(_watch$4, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }), _defineProperty(_watch$4, size, {
      handler: function handler(s) {
        this[inst].size = s;
      },
      immediate: true
    }), _defineProperty(_watch$4, noSizeAttenuation, {
      handler: function handler(v) {
        this[inst].sizeAttenuation = !v;
      },
      immediate: true
    }), _watch$4)
  };

  var defaultFragment = /* glsl */
`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`  ;

  var defaultVertex = /* glsl */
`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`  ;

  var _props$4, _watch$3;
  var vglShaderMaterial = {
    mixins: [VglMaterial],
    props: (_props$4 = {}, _defineProperty(_props$4, fragmentShader, {
      type: String,
      default: defaultFragment
    }), _defineProperty(_props$4, uniforms, {
      type: Object,
      default: function _default() {
        return {};
      }
    }), _defineProperty(_props$4, vertexShader, {
      type: String,
      default: defaultVertex
    }), _defineProperty(_props$4, wireframe, Boolean), _props$4),
    computed: _defineProperty({}, inst, function () {
      return new three.ShaderMaterial();
    }),
    watch: (_watch$3 = {}, _defineProperty(_watch$3, fragmentShader, {
      handler: function handler(f) {
        Object.assign(this[inst], {
          fragmentShader: f,
          needsUpdate: true
        });
      },
      immediate: true
    }), _defineProperty(_watch$3, vertexShader, {
      handler: function handler(v) {
        Object.assign(this[inst], {
          vertexShader: v,
          needsUpdate: true
        });
      },
      immediate: true
    }), _defineProperty(_watch$3, uniforms, {
      handler: function handler(u) {
        Object.assign(this[inst].uniforms, u);
      },
      immediate: true
    }), _defineProperty(_watch$3, wireframe, {
      handler: function handler(w) {
        this[inst].wireframe = w;
      },
      immediate: true
    }), _watch$3)
  };

  var vglShadowMaterial = {
    mixins: [VglMaterial],
    computed: _defineProperty({}, inst, function () {
      return new three.ShadowMaterial();
    })
  };

  var _props$3, _watch$2, _methods$5;
  var vglSpriteMaterial = {
    mixins: [VglMaterial],
    props: (_props$3 = {}, _defineProperty(_props$3, color, {
      type: [String, Number],
      default: 0xffffff
    }), _defineProperty(_props$3, rotation, {
      type: Number,
      default: 0
    }), _props$3),
    computed: _defineProperty({}, inst, function () {
      return new three.SpriteMaterial();
    }),
    watch: (_watch$2 = {}, _defineProperty(_watch$2, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }), _defineProperty(_watch$2, rotation, {
      handler: function handler(r) {
        this[inst].rotation = r;
      },
      immediate: true
    }), _watch$2),
    methods: (_methods$5 = {}, _defineProperty(_methods$5, add, function (slot, obj) {
      if (slot === map) this[inst].map = obj;else if (slot === alphaMap) this[inst].alphaMap = obj;
    }), _defineProperty(_methods$5, remove, function (slot, obj) {
      if (slot === map) {
        if (this[inst].map === obj) this[inst].map = null;
      } else if (slot === alphaMap && this[inst].alphaMap === obj) this[inst].alphaMap = null;
    }), _methods$5)
  };

  var vglGroup = {
    mixins: [VglObject3d],
    computed: _defineProperty({}, inst, function () {
      return new three.Group();
    })
  };

  var vglLineLoop = {
    mixins: [VglLine],
    computed: _defineProperty({}, inst, function () {
      return new three.LineLoop();
    })
  };

  var _methods$4;
  var vglMesh = {
    mixins: [VglObject3d],
    computed: _defineProperty({}, inst, function () {
      return new three.Mesh(defaultGeometry, defaultMeshMaterial);
    }),
    methods: (_methods$4 = {}, _defineProperty(_methods$4, add, function (slot, obj) {
      if (slot === geometry) this[inst].geometry = obj;else if (slot === material) {
        if (Array.isArray(this[inst].material)) this[inst].material.push(obj);else if (this[inst].material === defaultMeshMaterial) this[inst].material = obj;else this[inst].material = [this[inst].material, obj];
      } else VglObject3d.methods[add].call(this, slot, obj);
    }), _defineProperty(_methods$4, remove, function (slot, obj) {
      if (slot === geometry) {
        if (this[inst].geometry === obj) this[inst].geometry = defaultGeometry;
      } else if (slot === material) {
        if (Array.isArray(this[inst].material)) {
          var index = this[inst].material.indexOf(obj);

          if (index >= 0) {
            this[inst].material.splice(index, 1);

            if (this[inst].material.length === 1) {
              var _this$inst$material = _slicedToArray(this[inst].material, 1);

              this[inst].material = _this$inst$material[0];
            }
          }
        } else if (this[inst].material === obj) this[inst].material = defaultMeshMaterial;
      } else VglObject3d.methods[remove].call(this, slot, obj);
    }), _methods$4),

    /**
     * @slot geometry
     */

    /**
     * @slot material
     */
    render: undefined
  };

  var _methods$3;
  var vglPoints = {
    mixins: [VglObject3d],
    computed: _defineProperty({}, inst, function () {
      return new three.Points(defaultGeometry, defaultPointsMaterial);
    }),
    methods: (_methods$3 = {}, _defineProperty(_methods$3, add, function (slot, obj) {
      if (slot === geometry) this[inst].geometry = obj;else if (slot === material) this[inst].material = obj;else VglObject3d.methods[add].call(this, slot, obj);
    }), _defineProperty(_methods$3, remove, function (slot, obj) {
      if (slot === geometry) {
        if (this[inst].geometry === obj) this[inst].geometry = defaultGeometry;
      } else if (slot === material) {
        if (this[inst].material === obj) this[inst].material = defaultPointsMaterial;
      } else VglObject3d.methods[remove].call(this, slot, obj);
    }), _methods$3)
  };

  var _methods$2;
  var vglSprite = {
    mixins: [VglObject3d],
    computed: _defineProperty({}, inst, function () {
      return new three.Sprite(defaultSpriteMaterial);
    }),
    methods: (_methods$2 = {}, _defineProperty(_methods$2, add, function (slot, obj) {
      if (slot === material) this[inst].material = obj;else VglObject3d.methods[add].call(this, slot, obj);
    }), _defineProperty(_methods$2, remove, function (slot, obj) {
      if (slot === material) {
        if (this.inst.material === obj) this[inst].material = defaultSpriteMaterial;
      } else VglObject3d.methods[add].call(this, slot, obj);
    }), _methods$2)
  };

  var _props$2;
  var preferences = {
    highPerformance: 'high-performance',
    lowPower: 'low-power',
    default: 'default'
  };

  function serialize(object) {
    return Object.entries(object).sort().map(function (entry) {
      return entry[1];
    }).map(function (v) {
      if (v === true) return 1;
      if (v === false) return 0;
      return v;
    });
  }

  function key() {
    for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
      objects[_key] = arguments[_key];
    }

    return objects.flatMap(serialize).join('');
  }

  function attrs(vm, slot) {
    var _on;

    return {
      on: (_on = {}, _defineProperty(_on, add, function (obj) {
        var target = vm[inst];
        target[slot] = obj;
        vm.$nextTick(vm.render);
      }), _defineProperty(_on, remove, function (obj) {
        if (vm[inst][slot] === obj) {
          var target = vm[inst];
          delete target[slot];
        }
      }), _defineProperty(_on, change, function () {
        vm.$nextTick(vm.render);
      }), _on)
    };
  }

  var resizeHooks = globalThis.ResizeObserver ? {
    created: function created() {
      this.resizeObserver = new globalThis.ResizeObserver(this.render);
    },
    mounted: function mounted() {
      this.resizeObserver.observe(this.$el);
    },
    updated: function updated() {
      this.resizeObserver.disconnect();
      this.resizeObserver.observe(this.$el);
    },
    beforeDestroy: function beforeDestroy() {
      this.resizeObserver.disconnect();
      if (this[inst].renderer) this[inst].renderer.dispose();
    }
  } : {};
  var vglRenderer = _objectSpread2({
    props: (_props$2 = {}, _defineProperty(_props$2, alpha, Boolean), _defineProperty(_props$2, noPremultipliedAlpha, Boolean), _defineProperty(_props$2, antialias, Boolean), _defineProperty(_props$2, noStencil, Boolean), _defineProperty(_props$2, preserveDrawingBuffer, Boolean), _defineProperty(_props$2, noDepth, Boolean), _defineProperty(_props$2, logarithmicDepthBuffer, Boolean), _defineProperty(_props$2, shadowMapEnabled, Boolean), _defineProperty(_props$2, precision, {
      type: String,
      validator: function validator(v) {
        return ['highp', 'mediump', 'lowp'].includes(v);
      }
    }), _defineProperty(_props$2, powerPreference, {
      type: String,
      default: 'default',
      validator: function validator(v) {
        return v in preferences;
      }
    }), _props$2),
    computed: _defineProperty({}, inst, function () {
      return {
        parameters: {
          preserveDrawingBuffer: this[preserveDrawingBuffer],
          precision: this[precision],
          depth: !this[noDepth],
          alpha: this[alpha],
          stencil: !this[noStencil],
          logarithmicDepthBuffer: this[logarithmicDepthBuffer],
          antialias: this[antialias],
          powerPreference: preferences[this.powerPreference],
          premultipliedAlpha: !this[noPremultipliedAlpha]
        },
        shadowMap: {
          enabled: this[shadowMapEnabled]
        }
      };
    }),
    methods: {
      render: function render() {
        var _this = this;

        if (this[inst].toBeRendered) return;
        this.$nextTick(function () {
          var obj = _this[inst],
              $el = _this.$el;

          if (!obj.renderer) {
            obj.renderer = new three.WebGLRenderer(_objectSpread2({
              canvas: $el
            }, obj.parameters));
            Object.assign(obj.renderer.shadowMap, obj.shadowMap);
          }

          var s = obj[scene],
              c = obj[camera],
              r = obj.renderer;

          if (s && c) {
            var clientWidth = $el.clientWidth,
                clientHeight = $el.clientHeight;
            var restore;

            if (c instanceof three.PerspectiveCamera) {
              var aspect = c.aspect;

              if (aspect === undefined) {
                restore = {
                  aspect: aspect
                };
                c.aspect = clientWidth / clientHeight;
                c.updateProjectionMatrix();
              }
            } else if (c instanceof three.OrthographicCamera) {
              var left = c.left,
                  right = c.right,
                  top = c.top,
                  bottom = c.bottom;

              if ([left, right, top, bottom].includes(undefined)) {
                restore = {
                  left: left,
                  right: right,
                  top: top,
                  bottom: bottom
                };

                if (![left, right].includes(undefined)) {
                  var height = Math.abs(left - right) * (clientHeight / clientWidth);
                  if (bottom !== undefined) c.top = bottom + height;else if (top !== undefined) c.bottom = top - height;else Object.assign(c, {
                    top: height / 2,
                    bottom: height / -2
                  });
                } else if (![top, bottom].includes(undefined)) {
                  var width = Math.abs(top - bottom) * (clientWidth / clientHeight);
                  if (left !== undefined) c.right = left + width;else if (right !== undefined) c.left = right - width;else Object.assign(c, {
                    left: width / -2,
                    right: width / 2
                  });
                } else {
                  if (left !== undefined) c.right = left + clientWidth;else if (right !== undefined) c.left = right - clientWidth;else Object.assign(c, {
                    left: clientWidth / -2,
                    right: clientWidth / 2
                  });
                  if (top !== undefined) c.bottom = top - clientHeight;else if (bottom !== undefined) c.top = bottom + clientHeight;else Object.assign(c, {
                    top: clientHeight / 2,
                    bottom: clientHeight / -2
                  });
                }

                c.updateProjectionMatrix();
              }
            }

            if (obj.clientWidth !== clientWidth || obj.clientHeight !== clientHeight) {
              Object.assign(obj, {
                clientWidth: clientWidth,
                clientHeight: clientHeight
              });
              r.setSize(clientWidth, clientHeight, false);
            }

            r.render(s, c);
            if (restore) Object.assign(c, restore);
          }

          obj.toBeRendered = 0;
        });
        this[inst].toBeRendered = 1;
      }
    },
    watch: _defineProperty({}, inst, function (_, _ref) {
      var renderer = _ref.renderer;
      if (renderer) renderer.dispose();
    }),
    beforeDestroy: function beforeDestroy() {
      if (this[inst].renderer) this[inst].renderer.dispose();
    },
    render: function render(h) {
      var _this$inst = this[inst],
          parameters = _this$inst.parameters,
          shadowMap = _this$inst.shadowMap;
      return h('canvas', {
        key: key(parameters, shadowMap)
      }, [h(VglSlot, attrs(this, camera),
      /** @slot The camera to project scene objects. */
      this.$slots[camera]), h(VglSlot, attrs(this, scene),
      /** @slot The scene to be rendered. */
      this.$slots[scene]), h('template',
      /**
       * @slot The default slot can contain any components but they won't be rendered directly.
       * One of relevant case is putting `<vgl-def>` components and use them in (as) the scene.
       */
      this.$slots.default)]);
    }
  }, resizeHooks);

  var _props$1, _watch$1;
  var vglFog = {
    mixins: [VglSlotable],
    props: (_props$1 = {}, _defineProperty(_props$1, name, {
      default: '',
      type: String
    }), _defineProperty(_props$1, color, {
      type: [String, Number],
      default: 0xffffff
    }), _defineProperty(_props$1, near, {
      type: Number,
      default: 1
    }), _defineProperty(_props$1, far, {
      type: Number,
      default: 1000
    }), _props$1),
    computed: _defineProperty({}, inst, function () {
      return new three.Fog();
    }),
    watch: (_watch$1 = {}, _defineProperty(_watch$1, name, {
      handler: function handler(n) {
        this[inst].name = n;
      },
      immediate: true
    }), _defineProperty(_watch$1, near, {
      handler: function handler(n) {
        this[inst].near = n;
      },
      immediate: true
    }), _defineProperty(_watch$1, far, {
      handler: function handler(f) {
        this[inst].far = f;
      },
      immediate: true
    }), _defineProperty(_watch$1, color, {
      handler: function handler(c) {
        this[inst].color.set(c);
      },
      immediate: true
    }), _watch$1),
    render: function render() {}
  };

  var _methods$1;
  var vglScene = {
    mixins: [VglObject3d],
    props: _defineProperty({}, background, [String, Number]),
    computed: _defineProperty({}, inst, function () {
      return new three.Scene();
    }),
    watch: _defineProperty({}, background, {
      handler: function handler(c) {
        if (c === undefined) return;
        if (!this[inst].background) this[inst].background = new three.Color(c);else if (this[inst].background instanceof three.Color) this[inst].background.set(c);
      },
      immediate: true
    }),
    methods: (_methods$1 = {}, _defineProperty(_methods$1, add, function (slot, obj) {
      if (slot === fog) this[inst].fog = obj;else if (slot === overrideMaterial) this[inst].overrideMaterial = obj;else if (slot === environment) this[inst].environment = obj;else if (slot === background) this[inst].background = obj;else VglObject3d.methods[add].call(this, slot, obj);
    }), _defineProperty(_methods$1, remove, function (slot, obj) {
      if (slot === fog) {
        if (this[inst].fog === obj) this[inst].fog = null;
      } else if (slot === overrideMaterial) {
        if (this[inst].overrideMaterial === obj) this[inst].overrideMaterial = null;
      } else if (slot === environment) {
        if (this[inst].environment === obj) this[inst].environment = null;
      } else if (slot === background) {
        if (this[inst].background === obj) {
          this[inst].background = this[background] ? new three.Color(this[background]) : null;
        }
      } else VglObject3d.methods[remove].call(this, slot, obj);
    }), _methods$1),

    /**
     * @slot fog
     */

    /**
     * @slot overrideMaterial
     */

    /**
     * @slot background
     */

    /**
     * @slot environment
     */
    render: undefined
  };

  var mappings = {
    uv: three.UVMapping,
    cubeReflection: three.CubeReflectionMapping,
    cubeRefraction: three.CubeRefractionMapping,
    equirectangularReflection: three.EquirectangularReflectionMapping,
    equirectangularRefraction: three.EquirectangularRefractionMapping,
    cubeUvReflection: three.CubeUVReflectionMapping,
    cubeUvRefraction: three.CubeUVRefractionMapping
  };

  var wrappings = {
    repeat: three.RepeatWrapping,
    clampToEdge: three.ClampToEdgeWrapping,
    mirroredRepeat: three.MirroredRepeatWrapping
  };

  var filters = {
    nearest: three.NearestFilter,
    nearestMipMapNearest: three.NearestMipMapNearestFilter,
    nearestMipMapLinear: three.NearestMipMapLinearFilter,
    linear: three.LinearFilter,
    linearMipMapNearest: three.LinearMipMapNearestFilter,
    linearMipMapLinear: three.LinearMipMapLinearFilter
  };

  var formats = {
    alpha: three.AlphaFormat,
    rgb: three.RGBFormat,
    rgba: three.RGBAFormat,
    luminance: three.LuminanceFormat,
    luminanceAlpha: three.LuminanceAlphaFormat,
    rgbe: three.RGBEFormat,
    depth: three.DepthFormat,
    depthStencil: three.DepthStencilFormat
  };

  var types = {
    unsignedByte: three.UnsignedByteType,
    byte: three.ByteType,
    short: three.ShortType,
    int: three.IntType,
    unsignedShort: three.UnsignedShortType,
    unsignedInt: three.UnsignedIntType,
    float: three.FloatType,
    halfFloat: three.HalfFloatType,
    unsignedShort4444: three.UnsignedShort4444Type,
    unsignedShort5551: three.UnsignedShort5551Type,
    unsignedShort565: three.UnsignedShort565Type,
    unsignedInt248: three.UnsignedInt248Type
  };

  var encodings = {
    linear: three.LinearEncoding,
    sRgb: three.sRGBEncoding,
    gamma: three.GammaEncoding,
    rgbe: three.RGBEEncoding,
    logLuv: three.LogLuvEncoding,
    rgbm7: three.RGBM7Encoding,
    rgbm16: three.RGBM16Encoding,
    rgbde: three.RGBDEncoding,
    basicDepth: three.BasicDepthPacking,
    rgbaDepth: three.RGBADepthPacking
  };

  var _props, _methods, _watch;
  var vglTexture = {
    mixins: [VglSlotable, VglSlotHolder],
    props: (_props = {}, _defineProperty(_props, name, {
      type: String,
      default: ''
    }), _defineProperty(_props, mapping, {
      type: String,
      default: 'uv',
      validator: function validator(m) {
        return m in mappings;
      }
    }), _defineProperty(_props, wrapS, {
      type: String,
      default: 'clampToEdge',
      validator: function validator(s) {
        return s in wrappings;
      }
    }), _defineProperty(_props, wrapT, {
      type: String,
      default: 'clampToEdge',
      validator: function validator(t) {
        return t in wrappings;
      }
    }), _defineProperty(_props, magFilter, {
      type: String,
      default: 'linear',
      validator: function validator(m) {
        return m in filters;
      }
    }), _defineProperty(_props, minFilter, {
      type: String,
      default: 'linearMipMapLinear',
      validator: function validator(m) {
        return m in filters;
      }
    }), _defineProperty(_props, anisotropy, {
      type: Number,
      default: 1,
      validator: Number.isInteger
    }), _defineProperty(_props, format, {
      type: String,
      validator: function validator(f) {
        return f in formats;
      },
      default: 'rgba'
    }), _defineProperty(_props, type, {
      type: String,
      default: 'unsignedByte',
      validator: function validator(t) {
        return t in types;
      }
    }), _defineProperty(_props, offsetU, {
      type: Number,
      default: 0
    }), _defineProperty(_props, offsetV, {
      type: Number,
      default: 0
    }), _defineProperty(_props, repeatU, {
      type: Number,
      default: 1
    }), _defineProperty(_props, repeatV, {
      type: Number,
      default: 1
    }), _defineProperty(_props, rotation, {
      type: Number,
      default: 0
    }), _defineProperty(_props, centerU, {
      type: Number,
      default: 0
    }), _defineProperty(_props, centerV, {
      type: Number,
      default: 0
    }), _defineProperty(_props, premultiplyAlpha, Boolean), _defineProperty(_props, noFlipY, Boolean), _defineProperty(_props, unpackAlignment, {
      type: Number,
      default: 4,
      validator: function validator(v) {
        return [1, 2, 4, 8].includes(v);
      }
    }), _defineProperty(_props, encoding, {
      type: String,
      default: 'linear',
      validator: function validator(e) {
        return e in encodings;
      }
    }), _props),
    computed: _defineProperty({}, inst, function () {
      return new three.Texture();
    }),
    methods: (_methods = {}, _defineProperty(_methods, add, function (slot, obj) {
      if (slot === image) Object.assign(this[inst], {
        image: obj,
        needsUpdate: true
      });
    }), _defineProperty(_methods, remove, function (slot, obj) {
      if (slot === image && this[inst].image === obj) {
        Object.assign(this[inst], {
          image: three.Texture.DEFAULT_IMAGE,
          needsUpdate: true
        });
      }
    }), _defineProperty(_methods, change, function (slot) {
      if (slot === image) this[inst].needsUpdate = true;
      VglSlotable.methods[change].call(this, slot);
    }), _methods),
    beforeDestroy: function beforeDestroy() {
      this[inst].dispose();
    },
    watch: (_watch = {}, _defineProperty(_watch, name, {
      handler: function handler(n) {
        this[inst].name = n;
      },
      immediate: true
    }), _defineProperty(_watch, mapping, {
      handler: function handler(m) {
        this[inst].mapping = mappings[m];
      },
      immediate: true
    }), _defineProperty(_watch, wrapS, {
      handler: function handler(s) {
        this[inst].wrapS = wrappings[s];
      },
      immediate: true
    }), _defineProperty(_watch, wrapT, {
      handler: function handler(t) {
        this[inst].wrapT = wrappings[t];
      },
      immediate: true
    }), _defineProperty(_watch, magFilter, {
      handler: function handler(f) {
        this[inst].magFilter = filters[f];
      },
      immediate: true
    }), _defineProperty(_watch, minFilter, {
      handler: function handler(f) {
        this[inst].minFilter = filters[f];
      },
      immediate: true
    }), _defineProperty(_watch, anisotropy, {
      handler: function handler(a) {
        this[inst].anisotropy = a;
      },
      immediate: true
    }), _defineProperty(_watch, format, {
      handler: function handler(f) {
        this[inst].format = formats[f];
      },
      immediate: true
    }), _defineProperty(_watch, type, {
      handler: function handler(t) {
        this[inst].type = types[t];
      },
      immediate: true
    }), _defineProperty(_watch, offsetU, {
      handler: function handler(u) {
        this[inst].offset.setX(u);
      },
      immediate: true
    }), _defineProperty(_watch, offsetV, {
      handler: function handler(v) {
        this[inst].offset.setY(v);
      },
      immediate: true
    }), _defineProperty(_watch, repeatU, {
      handler: function handler(u) {
        this[inst].repeat.setX(u);
      },
      immediate: true
    }), _defineProperty(_watch, repeatV, {
      handler: function handler(v) {
        this[inst].repeat.setY(v);
      },
      immediate: true
    }), _defineProperty(_watch, rotation, {
      handler: function handler(r) {
        this[inst].rotation = r;
      },
      immediate: true
    }), _defineProperty(_watch, centerU, {
      handler: function handler(u) {
        this[inst].center.setX(u);
      },
      immediate: true
    }), _defineProperty(_watch, centerV, {
      handler: function handler(v) {
        this[inst].center.setY(v);
      },
      immediate: true
    }), _defineProperty(_watch, premultiplyAlpha, {
      handler: function handler(p) {
        this[inst].premultiplyAlpha = p;
      },
      immediate: true
    }), _defineProperty(_watch, noFlipY, {
      handler: function handler(f) {
        this[inst].flipY = !f;
      },
      immediate: true
    }), _defineProperty(_watch, unpackAlignment, {
      handler: function handler(u) {
        this[inst].unpackAlignment = u;
      },
      immediate: true
    }), _defineProperty(_watch, encoding, {
      handler: function handler(e) {
        this[inst].encoding = encodings[e];
      },
      immediate: true
    }), _watch),

    /**
     * A `<vgl-image>` component to be used as the texture image.
     * @slot image
     */
    render: undefined
  };

  exports.VglAmbientLight = vglAmbientLight;
  exports.VglArrowHelper = vglArrowHelper;
  exports.VglAxesHelper = vglAxesHelper;
  exports.VglBoxGeometry = vglBoxGeometry;
  exports.VglBoxHelper = vglBoxHelper;
  exports.VglCamera = VglCamera;
  exports.VglCameraHelper = vglCameraHelper;
  exports.VglCircleGeometry = vglCircleGeometry;
  exports.VglConeGeometry = vglConeGeometry;
  exports.VglCurve = VglCurve;
  exports.VglCurvePath = VglCurvePath;
  exports.VglCylinderGeometry = VglCylinderGeometry;
  exports.VglDefs = vglDefs;
  exports.VglDirectionalLight = vglDirectionalLight;
  exports.VglDirectionalLightHelper = vglDirectionalLightHelper;
  exports.VglDodecahedronGeometry = vglDodecahedronGeometry;
  exports.VglExtrudeGeometry = VglExtrudeGeometry;
  exports.VglFloat32Attribute = vglFloat32Attribute;
  exports.VglFloat64Attribute = vglFloat64Attribute;
  exports.VglFog = vglFog;
  exports.VglFont = vglFont;
  exports.VglGeometry = VglGeometry;
  exports.VglGridHelper = vglGridHelper;
  exports.VglGroup = vglGroup;
  exports.VglHemisphereLight = vglHemisphereLight;
  exports.VglIcosahedronGeometry = vglIcosahedronGeometry;
  exports.VglImage = vglImage;
  exports.VglInt16Attribute = vglInt16Attribute;
  exports.VglInt32Attribute = vglInt32Attribute;
  exports.VglInt8Attribute = vglInt8Attribute;
  exports.VglLatheGeometry = vglLatheGeometry;
  exports.VglLight = VglLight;
  exports.VglLine = VglLine;
  exports.VglLineBasicMaterial = vglLineBasicMaterial;
  exports.VglLineDashedMaterial = vglLineDashedMaterial;
  exports.VglLineLoop = vglLineLoop;
  exports.VglLineSegments = VglLineSegments;
  exports.VglMaterial = VglMaterial;
  exports.VglMesh = vglMesh;
  exports.VglMeshBasicMaterial = vglMeshBasicMaterial;
  exports.VglMeshDepthMaterial = vglMeshDepthMaterial;
  exports.VglMeshLambertMaterial = vglMeshLambertMaterial;
  exports.VglMeshNormalMaterial = vglMeshNormalMaterial;
  exports.VglMeshPhongMaterial = vglMeshPhongMaterial;
  exports.VglMeshPhysicalMaterial = vglMeshPhysicalMaterial;
  exports.VglMeshStandardMaterial = VglMeshStandardMaterial;
  exports.VglMeshToonMaterial = vglMeshToonMaterial;
  exports.VglObject3d = VglObject3d;
  exports.VglOctahedronGeometry = vglOctahedronGeometry;
  exports.VglOrthographicCamera = vglOrthographicCamera;
  exports.VglPath = VglPath;
  exports.VglPerspectiveCamera = vglPerspectiveCamera;
  exports.VglPlaneGeometry = vglPlaneGeometry;
  exports.VglPointLight = vglPointLight;
  exports.VglPoints = vglPoints;
  exports.VglPointsMaterial = vglPointsMaterial;
  exports.VglPolarGridHelper = vglPolarGridHelper;
  exports.VglPolyhedronGeometry = VglPolyhedronGeometry;
  exports.VglRectAreaLight = vglRectAreaLight;
  exports.VglRenderer = vglRenderer;
  exports.VglRingGeometry = vglRingGeometry;
  exports.VglScene = vglScene;
  exports.VglShaderMaterial = vglShaderMaterial;
  exports.VglShadowMaterial = vglShadowMaterial;
  exports.VglShape = vglShape;
  exports.VglShapeGeometry = vglShapeGeometry;
  exports.VglSphereGeometry = vglSphereGeometry;
  exports.VglSpotLight = vglSpotLight;
  exports.VglSpotLightHelper = vglSpotLightHelper;
  exports.VglSprite = vglSprite;
  exports.VglSpriteMaterial = vglSpriteMaterial;
  exports.VglTetrahedronGeometry = vglTetrahedronGeometry;
  exports.VglTextGeometry = vglTextGeometry;
  exports.VglTexture = vglTexture;
  exports.VglTorusGeometry = vglTorusGeometry;
  exports.VglTorusKnotGeometry = vglTorusKnotGeometry;
  exports.VglUint16Attribute = vglUint16Attribute;
  exports.VglUint32Attribute = vglUint32Attribute;
  exports.VglUint8Attribute = vglUint8Attribute;
  exports.VglUint8ClampedAttribute = vglUint8ClampedAttribute;
  exports.VglUse = vglUse;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
